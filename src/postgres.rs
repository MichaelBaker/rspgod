/* automatically generated by rust-bindgen */

pub type __int128_t = ::libc::c_void;
pub type __uint128_t = ::libc::c_void;
pub type __builtin_va_list = [__va_list_tag; 1usize];
pub type Oid = ::libc::c_uint;
pub type pg_int64 = ::libc::c_long;
pub type __int8_t = ::libc::c_char;
pub type __uint8_t = ::libc::c_uchar;
pub type __int16_t = ::libc::c_short;
pub type __uint16_t = ::libc::c_ushort;
pub type __int32_t = ::libc::c_int;
pub type __uint32_t = ::libc::c_uint;
pub type __int64_t = ::libc::c_longlong;
pub type __uint64_t = ::libc::c_ulonglong;
pub type __darwin_intptr_t = ::libc::c_long;
pub type __darwin_natural_t = ::libc::c_uint;
pub type __darwin_ct_rune_t = ::libc::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed1 {
    pub _bindgen_data_: [u64; 16usize],
}
impl Union_Unnamed1 {
    pub unsafe fn __mbstate8(&mut self) -> *mut [::libc::c_char; 128usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn _mbstateL(&mut self) -> *mut ::libc::c_longlong {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed1 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __mbstate_t = Union_Unnamed1;
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::libc::c_long;
pub type __darwin_size_t = ::libc::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::libc::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::libc::c_int;
pub type __darwin_clock_t = ::libc::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::libc::c_long;
pub type __darwin_time_t = ::libc::c_long;
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<extern "C" fn(arg1:
                                                           *mut ::libc::c_void)
                                             -> ()>,
    pub __arg: *mut ::libc::c_void,
    pub __next: *mut Struct___darwin_pthread_handler_rec,
}
impl ::std::clone::Clone for Struct___darwin_pthread_handler_rec {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_pthread_handler_rec {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__opaque_pthread_attr_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char; 56usize],
}
impl ::std::clone::Clone for Struct__opaque_pthread_attr_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__opaque_pthread_attr_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__opaque_pthread_cond_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char; 40usize],
}
impl ::std::clone::Clone for Struct__opaque_pthread_cond_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__opaque_pthread_cond_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__opaque_pthread_condattr_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char; 8usize],
}
impl ::std::clone::Clone for Struct__opaque_pthread_condattr_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__opaque_pthread_condattr_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__opaque_pthread_mutex_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char; 56usize],
}
impl ::std::clone::Clone for Struct__opaque_pthread_mutex_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__opaque_pthread_mutex_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__opaque_pthread_mutexattr_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char; 8usize],
}
impl ::std::clone::Clone for Struct__opaque_pthread_mutexattr_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__opaque_pthread_mutexattr_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__opaque_pthread_once_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char; 8usize],
}
impl ::std::clone::Clone for Struct__opaque_pthread_once_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__opaque_pthread_once_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__opaque_pthread_rwlock_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char; 192usize],
}
impl ::std::clone::Clone for Struct__opaque_pthread_rwlock_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__opaque_pthread_rwlock_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__opaque_pthread_rwlockattr_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char; 16usize],
}
impl ::std::clone::Clone for Struct__opaque_pthread_rwlockattr_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__opaque_pthread_rwlockattr_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__opaque_pthread_t {
    pub __sig: ::libc::c_long,
    pub __cleanup_stack: *mut Struct___darwin_pthread_handler_rec,
    pub __opaque: [::libc::c_char; 1168usize],
}
impl ::std::clone::Clone for Struct__opaque_pthread_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__opaque_pthread_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::libc::c_uint;
pub type __darwin_fsfilcnt_t = ::libc::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_pthread_attr_t = Struct__opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = Struct__opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = Struct__opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::libc::c_ulong;
pub type __darwin_pthread_mutex_t = Struct__opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = Struct__opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = Struct__opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = Struct__opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = Struct__opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut Struct__opaque_pthread_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::libc::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::libc::c_char; 37usize];
pub type __darwin_nl_item = ::libc::c_int;
pub type __darwin_wctrans_t = ::libc::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type va_list = __builtin_va_list;
pub type size_t = __darwin_size_t;
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct___sbuf {
    pub _base: *mut ::libc::c_uchar,
    pub _size: ::libc::c_int,
}
impl ::std::clone::Clone for Struct___sbuf {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___sbuf {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct___sFILEX { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct___sFILE {
    pub _p: *mut ::libc::c_uchar,
    pub _r: ::libc::c_int,
    pub _w: ::libc::c_int,
    pub _flags: ::libc::c_short,
    pub _file: ::libc::c_short,
    pub _bf: Struct___sbuf,
    pub _lbfsize: ::libc::c_int,
    pub _cookie: *mut ::libc::c_void,
    pub _close: ::std::option::Option<extern "C" fn(arg1: *mut ::libc::c_void)
                                          -> ::libc::c_int>,
    pub _read: ::std::option::Option<extern "C" fn(arg1: *mut ::libc::c_void,
                                                   arg2: *mut ::libc::c_char,
                                                   arg3: ::libc::c_int)
                                         -> ::libc::c_int>,
    pub _seek: ::std::option::Option<extern "C" fn(arg1: *mut ::libc::c_void,
                                                   arg2: fpos_t,
                                                   arg3: ::libc::c_int)
                                         -> fpos_t>,
    pub _write: ::std::option::Option<extern "C" fn(arg1: *mut ::libc::c_void,
                                                    arg2:
                                                        *const ::libc::c_char,
                                                    arg3: ::libc::c_int)
                                          -> ::libc::c_int>,
    pub _ub: Struct___sbuf,
    pub _extra: *mut Struct___sFILEX,
    pub _ur: ::libc::c_int,
    pub _ubuf: [::libc::c_uchar; 3usize],
    pub _nbuf: [::libc::c_uchar; 1usize],
    pub _lb: Struct___sbuf,
    pub _blksize: ::libc::c_int,
    pub _offset: fpos_t,
}
impl ::std::clone::Clone for Struct___sFILE {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___sFILE {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FILE = Struct___sFILE;
pub type off_t = __darwin_off_t;
pub type ssize_t = __darwin_ssize_t;
pub type Enum_Unnamed2 = ::libc::c_uint;
pub const P_ALL: ::libc::c_uint = 0;
pub const P_PID: ::libc::c_uint = 1;
pub const P_PGID: ::libc::c_uint = 2;
pub type idtype_t = Enum_Unnamed2;
pub type pid_t = __darwin_pid_t;
pub type id_t = __darwin_id_t;
pub type sig_atomic_t = ::libc::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_i386_thread_state {
    pub __eax: ::libc::c_uint,
    pub __ebx: ::libc::c_uint,
    pub __ecx: ::libc::c_uint,
    pub __edx: ::libc::c_uint,
    pub __edi: ::libc::c_uint,
    pub __esi: ::libc::c_uint,
    pub __ebp: ::libc::c_uint,
    pub __esp: ::libc::c_uint,
    pub __ss: ::libc::c_uint,
    pub __eflags: ::libc::c_uint,
    pub __eip: ::libc::c_uint,
    pub __cs: ::libc::c_uint,
    pub __ds: ::libc::c_uint,
    pub __es: ::libc::c_uint,
    pub __fs: ::libc::c_uint,
    pub __gs: ::libc::c_uint,
}
impl ::std::clone::Clone for Struct___darwin_i386_thread_state {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_i386_thread_state {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_fp_control {
    pub _bindgen_bitfield_1_: ::libc::c_ushort,
}
impl ::std::clone::Clone for Struct___darwin_fp_control {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_fp_control {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __darwin_fp_control_t = Struct___darwin_fp_control;
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_fp_status {
    pub _bindgen_bitfield_1_: ::libc::c_ushort,
}
impl ::std::clone::Clone for Struct___darwin_fp_status {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_fp_status {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __darwin_fp_status_t = Struct___darwin_fp_status;
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_mmst_reg {
    pub __mmst_reg: [::libc::c_char; 10usize],
    pub __mmst_rsrv: [::libc::c_char; 6usize],
}
impl ::std::clone::Clone for Struct___darwin_mmst_reg {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_mmst_reg {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_xmm_reg {
    pub __xmm_reg: [::libc::c_char; 16usize],
}
impl ::std::clone::Clone for Struct___darwin_xmm_reg {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_xmm_reg {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_i386_float_state {
    pub __fpu_reserved: [::libc::c_int; 2usize],
    pub __fpu_fcw: Struct___darwin_fp_control,
    pub __fpu_fsw: Struct___darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: Struct___darwin_mmst_reg,
    pub __fpu_stmm1: Struct___darwin_mmst_reg,
    pub __fpu_stmm2: Struct___darwin_mmst_reg,
    pub __fpu_stmm3: Struct___darwin_mmst_reg,
    pub __fpu_stmm4: Struct___darwin_mmst_reg,
    pub __fpu_stmm5: Struct___darwin_mmst_reg,
    pub __fpu_stmm6: Struct___darwin_mmst_reg,
    pub __fpu_stmm7: Struct___darwin_mmst_reg,
    pub __fpu_xmm0: Struct___darwin_xmm_reg,
    pub __fpu_xmm1: Struct___darwin_xmm_reg,
    pub __fpu_xmm2: Struct___darwin_xmm_reg,
    pub __fpu_xmm3: Struct___darwin_xmm_reg,
    pub __fpu_xmm4: Struct___darwin_xmm_reg,
    pub __fpu_xmm5: Struct___darwin_xmm_reg,
    pub __fpu_xmm6: Struct___darwin_xmm_reg,
    pub __fpu_xmm7: Struct___darwin_xmm_reg,
    pub __fpu_rsrv4: [::libc::c_char; 224usize],
    pub __fpu_reserved1: ::libc::c_int,
}
impl ::std::clone::Clone for Struct___darwin_i386_float_state {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_i386_float_state {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_i386_avx_state {
    pub __fpu_reserved: [::libc::c_int; 2usize],
    pub __fpu_fcw: Struct___darwin_fp_control,
    pub __fpu_fsw: Struct___darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: Struct___darwin_mmst_reg,
    pub __fpu_stmm1: Struct___darwin_mmst_reg,
    pub __fpu_stmm2: Struct___darwin_mmst_reg,
    pub __fpu_stmm3: Struct___darwin_mmst_reg,
    pub __fpu_stmm4: Struct___darwin_mmst_reg,
    pub __fpu_stmm5: Struct___darwin_mmst_reg,
    pub __fpu_stmm6: Struct___darwin_mmst_reg,
    pub __fpu_stmm7: Struct___darwin_mmst_reg,
    pub __fpu_xmm0: Struct___darwin_xmm_reg,
    pub __fpu_xmm1: Struct___darwin_xmm_reg,
    pub __fpu_xmm2: Struct___darwin_xmm_reg,
    pub __fpu_xmm3: Struct___darwin_xmm_reg,
    pub __fpu_xmm4: Struct___darwin_xmm_reg,
    pub __fpu_xmm5: Struct___darwin_xmm_reg,
    pub __fpu_xmm6: Struct___darwin_xmm_reg,
    pub __fpu_xmm7: Struct___darwin_xmm_reg,
    pub __fpu_rsrv4: [::libc::c_char; 224usize],
    pub __fpu_reserved1: ::libc::c_int,
    pub __avx_reserved1: [::libc::c_char; 64usize],
    pub __fpu_ymmh0: Struct___darwin_xmm_reg,
    pub __fpu_ymmh1: Struct___darwin_xmm_reg,
    pub __fpu_ymmh2: Struct___darwin_xmm_reg,
    pub __fpu_ymmh3: Struct___darwin_xmm_reg,
    pub __fpu_ymmh4: Struct___darwin_xmm_reg,
    pub __fpu_ymmh5: Struct___darwin_xmm_reg,
    pub __fpu_ymmh6: Struct___darwin_xmm_reg,
    pub __fpu_ymmh7: Struct___darwin_xmm_reg,
}
impl ::std::clone::Clone for Struct___darwin_i386_avx_state {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_i386_avx_state {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_i386_exception_state {
    pub __trapno: __uint16_t,
    pub __cpu: __uint16_t,
    pub __err: __uint32_t,
    pub __faultvaddr: __uint32_t,
}
impl ::std::clone::Clone for Struct___darwin_i386_exception_state {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_i386_exception_state {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_x86_debug_state32 {
    pub __dr0: ::libc::c_uint,
    pub __dr1: ::libc::c_uint,
    pub __dr2: ::libc::c_uint,
    pub __dr3: ::libc::c_uint,
    pub __dr4: ::libc::c_uint,
    pub __dr5: ::libc::c_uint,
    pub __dr6: ::libc::c_uint,
    pub __dr7: ::libc::c_uint,
}
impl ::std::clone::Clone for Struct___darwin_x86_debug_state32 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_x86_debug_state32 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_x86_thread_state64 {
    pub __rax: __uint64_t,
    pub __rbx: __uint64_t,
    pub __rcx: __uint64_t,
    pub __rdx: __uint64_t,
    pub __rdi: __uint64_t,
    pub __rsi: __uint64_t,
    pub __rbp: __uint64_t,
    pub __rsp: __uint64_t,
    pub __r8: __uint64_t,
    pub __r9: __uint64_t,
    pub __r10: __uint64_t,
    pub __r11: __uint64_t,
    pub __r12: __uint64_t,
    pub __r13: __uint64_t,
    pub __r14: __uint64_t,
    pub __r15: __uint64_t,
    pub __rip: __uint64_t,
    pub __rflags: __uint64_t,
    pub __cs: __uint64_t,
    pub __fs: __uint64_t,
    pub __gs: __uint64_t,
}
impl ::std::clone::Clone for Struct___darwin_x86_thread_state64 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_x86_thread_state64 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_x86_float_state64 {
    pub __fpu_reserved: [::libc::c_int; 2usize],
    pub __fpu_fcw: Struct___darwin_fp_control,
    pub __fpu_fsw: Struct___darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: Struct___darwin_mmst_reg,
    pub __fpu_stmm1: Struct___darwin_mmst_reg,
    pub __fpu_stmm2: Struct___darwin_mmst_reg,
    pub __fpu_stmm3: Struct___darwin_mmst_reg,
    pub __fpu_stmm4: Struct___darwin_mmst_reg,
    pub __fpu_stmm5: Struct___darwin_mmst_reg,
    pub __fpu_stmm6: Struct___darwin_mmst_reg,
    pub __fpu_stmm7: Struct___darwin_mmst_reg,
    pub __fpu_xmm0: Struct___darwin_xmm_reg,
    pub __fpu_xmm1: Struct___darwin_xmm_reg,
    pub __fpu_xmm2: Struct___darwin_xmm_reg,
    pub __fpu_xmm3: Struct___darwin_xmm_reg,
    pub __fpu_xmm4: Struct___darwin_xmm_reg,
    pub __fpu_xmm5: Struct___darwin_xmm_reg,
    pub __fpu_xmm6: Struct___darwin_xmm_reg,
    pub __fpu_xmm7: Struct___darwin_xmm_reg,
    pub __fpu_xmm8: Struct___darwin_xmm_reg,
    pub __fpu_xmm9: Struct___darwin_xmm_reg,
    pub __fpu_xmm10: Struct___darwin_xmm_reg,
    pub __fpu_xmm11: Struct___darwin_xmm_reg,
    pub __fpu_xmm12: Struct___darwin_xmm_reg,
    pub __fpu_xmm13: Struct___darwin_xmm_reg,
    pub __fpu_xmm14: Struct___darwin_xmm_reg,
    pub __fpu_xmm15: Struct___darwin_xmm_reg,
    pub __fpu_rsrv4: [::libc::c_char; 96usize],
    pub __fpu_reserved1: ::libc::c_int,
}
impl ::std::clone::Clone for Struct___darwin_x86_float_state64 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_x86_float_state64 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_x86_avx_state64 {
    pub __fpu_reserved: [::libc::c_int; 2usize],
    pub __fpu_fcw: Struct___darwin_fp_control,
    pub __fpu_fsw: Struct___darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: Struct___darwin_mmst_reg,
    pub __fpu_stmm1: Struct___darwin_mmst_reg,
    pub __fpu_stmm2: Struct___darwin_mmst_reg,
    pub __fpu_stmm3: Struct___darwin_mmst_reg,
    pub __fpu_stmm4: Struct___darwin_mmst_reg,
    pub __fpu_stmm5: Struct___darwin_mmst_reg,
    pub __fpu_stmm6: Struct___darwin_mmst_reg,
    pub __fpu_stmm7: Struct___darwin_mmst_reg,
    pub __fpu_xmm0: Struct___darwin_xmm_reg,
    pub __fpu_xmm1: Struct___darwin_xmm_reg,
    pub __fpu_xmm2: Struct___darwin_xmm_reg,
    pub __fpu_xmm3: Struct___darwin_xmm_reg,
    pub __fpu_xmm4: Struct___darwin_xmm_reg,
    pub __fpu_xmm5: Struct___darwin_xmm_reg,
    pub __fpu_xmm6: Struct___darwin_xmm_reg,
    pub __fpu_xmm7: Struct___darwin_xmm_reg,
    pub __fpu_xmm8: Struct___darwin_xmm_reg,
    pub __fpu_xmm9: Struct___darwin_xmm_reg,
    pub __fpu_xmm10: Struct___darwin_xmm_reg,
    pub __fpu_xmm11: Struct___darwin_xmm_reg,
    pub __fpu_xmm12: Struct___darwin_xmm_reg,
    pub __fpu_xmm13: Struct___darwin_xmm_reg,
    pub __fpu_xmm14: Struct___darwin_xmm_reg,
    pub __fpu_xmm15: Struct___darwin_xmm_reg,
    pub __fpu_rsrv4: [::libc::c_char; 96usize],
    pub __fpu_reserved1: ::libc::c_int,
    pub __avx_reserved1: [::libc::c_char; 64usize],
    pub __fpu_ymmh0: Struct___darwin_xmm_reg,
    pub __fpu_ymmh1: Struct___darwin_xmm_reg,
    pub __fpu_ymmh2: Struct___darwin_xmm_reg,
    pub __fpu_ymmh3: Struct___darwin_xmm_reg,
    pub __fpu_ymmh4: Struct___darwin_xmm_reg,
    pub __fpu_ymmh5: Struct___darwin_xmm_reg,
    pub __fpu_ymmh6: Struct___darwin_xmm_reg,
    pub __fpu_ymmh7: Struct___darwin_xmm_reg,
    pub __fpu_ymmh8: Struct___darwin_xmm_reg,
    pub __fpu_ymmh9: Struct___darwin_xmm_reg,
    pub __fpu_ymmh10: Struct___darwin_xmm_reg,
    pub __fpu_ymmh11: Struct___darwin_xmm_reg,
    pub __fpu_ymmh12: Struct___darwin_xmm_reg,
    pub __fpu_ymmh13: Struct___darwin_xmm_reg,
    pub __fpu_ymmh14: Struct___darwin_xmm_reg,
    pub __fpu_ymmh15: Struct___darwin_xmm_reg,
}
impl ::std::clone::Clone for Struct___darwin_x86_avx_state64 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_x86_avx_state64 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_x86_exception_state64 {
    pub __trapno: __uint16_t,
    pub __cpu: __uint16_t,
    pub __err: __uint32_t,
    pub __faultvaddr: __uint64_t,
}
impl ::std::clone::Clone for Struct___darwin_x86_exception_state64 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_x86_exception_state64 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_x86_debug_state64 {
    pub __dr0: __uint64_t,
    pub __dr1: __uint64_t,
    pub __dr2: __uint64_t,
    pub __dr3: __uint64_t,
    pub __dr4: __uint64_t,
    pub __dr5: __uint64_t,
    pub __dr6: __uint64_t,
    pub __dr7: __uint64_t,
}
impl ::std::clone::Clone for Struct___darwin_x86_debug_state64 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_x86_debug_state64 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_mcontext32 {
    pub __es: Struct___darwin_i386_exception_state,
    pub __ss: Struct___darwin_i386_thread_state,
    pub __fs: Struct___darwin_i386_float_state,
}
impl ::std::clone::Clone for Struct___darwin_mcontext32 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_mcontext32 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_mcontext_avx32 {
    pub __es: Struct___darwin_i386_exception_state,
    pub __ss: Struct___darwin_i386_thread_state,
    pub __fs: Struct___darwin_i386_avx_state,
}
impl ::std::clone::Clone for Struct___darwin_mcontext_avx32 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_mcontext_avx32 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_mcontext64 {
    pub __es: Struct___darwin_x86_exception_state64,
    pub __ss: Struct___darwin_x86_thread_state64,
    pub __fs: Struct___darwin_x86_float_state64,
}
impl ::std::clone::Clone for Struct___darwin_mcontext64 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_mcontext64 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_mcontext_avx64 {
    pub __es: Struct___darwin_x86_exception_state64,
    pub __ss: Struct___darwin_x86_thread_state64,
    pub __fs: Struct___darwin_x86_avx_state64,
}
impl ::std::clone::Clone for Struct___darwin_mcontext_avx64 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_mcontext_avx64 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type mcontext_t = *mut Struct___darwin_mcontext64;
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_sigaltstack {
    pub ss_sp: *mut ::libc::c_void,
    pub ss_size: __darwin_size_t,
    pub ss_flags: ::libc::c_int,
}
impl ::std::clone::Clone for Struct___darwin_sigaltstack {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_sigaltstack {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type stack_t = Struct___darwin_sigaltstack;
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_ucontext {
    pub uc_onstack: ::libc::c_int,
    pub uc_sigmask: __darwin_sigset_t,
    pub uc_stack: Struct___darwin_sigaltstack,
    pub uc_link: *mut Struct___darwin_ucontext,
    pub uc_mcsize: __darwin_size_t,
    pub uc_mcontext: *mut Struct___darwin_mcontext64,
}
impl ::std::clone::Clone for Struct___darwin_ucontext {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_ucontext {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ucontext_t = Struct___darwin_ucontext;
pub type pthread_attr_t = __darwin_pthread_attr_t;
pub type sigset_t = __darwin_sigset_t;
pub type uid_t = __darwin_uid_t;
#[repr(C)]
#[derive(Copy)]
pub struct Union_sigval {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_sigval {
    pub unsafe fn sival_int(&mut self) -> *mut ::libc::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn sival_ptr(&mut self) -> *mut *mut ::libc::c_void {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_sigval {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_sigval {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sigevent {
    pub sigev_notify: ::libc::c_int,
    pub sigev_signo: ::libc::c_int,
    pub sigev_value: Union_sigval,
    pub sigev_notify_function: ::std::option::Option<extern "C" fn(arg1:
                                                                       Union_sigval)
                                                         -> ()>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
impl ::std::clone::Clone for Struct_sigevent {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sigevent {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___siginfo {
    pub si_signo: ::libc::c_int,
    pub si_errno: ::libc::c_int,
    pub si_code: ::libc::c_int,
    pub si_pid: pid_t,
    pub si_uid: uid_t,
    pub si_status: ::libc::c_int,
    pub si_addr: *mut ::libc::c_void,
    pub si_value: Union_sigval,
    pub si_band: ::libc::c_long,
    pub __pad: [::libc::c_ulong; 7usize],
}
impl ::std::clone::Clone for Struct___siginfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___siginfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type siginfo_t = Struct___siginfo;
#[repr(C)]
#[derive(Copy)]
pub struct Union___sigaction_u {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union___sigaction_u {
    pub unsafe fn __sa_handler(&mut self)
     -> *mut ::std::option::Option<extern "C" fn(arg1: ::libc::c_int) -> ()> {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __sa_sigaction(&mut self)
     ->
         *mut ::std::option::Option<extern "C" fn(arg1: ::libc::c_int,
                                                  arg2: *mut Struct___siginfo,
                                                  arg3: *mut ::libc::c_void)
                                        -> ()> {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union___sigaction_u {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union___sigaction_u {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___sigaction {
    pub __sigaction_u: Union___sigaction_u,
    pub sa_tramp: ::std::option::Option<extern "C" fn(arg1:
                                                          *mut ::libc::c_void,
                                                      arg2: ::libc::c_int,
                                                      arg3: ::libc::c_int,
                                                      arg4: *mut siginfo_t,
                                                      arg5:
                                                          *mut ::libc::c_void)
                                            -> ()>,
    pub sa_mask: sigset_t,
    pub sa_flags: ::libc::c_int,
}
impl ::std::clone::Clone for Struct___sigaction {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___sigaction {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sigaction {
    pub __sigaction_u: Union___sigaction_u,
    pub sa_mask: sigset_t,
    pub sa_flags: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_sigaction {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sigaction {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type sig_t =
    ::std::option::Option<extern "C" fn(arg1: ::libc::c_int) -> ()>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sigvec {
    pub sv_handler: ::std::option::Option<extern "C" fn(arg1: ::libc::c_int)
                                              -> ()>,
    pub sv_mask: ::libc::c_int,
    pub sv_flags: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_sigvec {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sigvec {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sigstack {
    pub ss_sp: *mut ::libc::c_char,
    pub ss_onstack: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_sigstack {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sigstack {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type int8_t = ::libc::c_char;
pub type int16_t = ::libc::c_short;
pub type int32_t = ::libc::c_int;
pub type int64_t = ::libc::c_longlong;
pub type uint8_t = ::libc::c_uchar;
pub type uint16_t = ::libc::c_ushort;
pub type uint32_t = ::libc::c_uint;
pub type uint64_t = ::libc::c_ulonglong;
pub type int_least8_t = int8_t;
pub type int_least16_t = int16_t;
pub type int_least32_t = int32_t;
pub type int_least64_t = int64_t;
pub type uint_least8_t = uint8_t;
pub type uint_least16_t = uint16_t;
pub type uint_least32_t = uint32_t;
pub type uint_least64_t = uint64_t;
pub type int_fast8_t = int8_t;
pub type int_fast16_t = int16_t;
pub type int_fast32_t = int32_t;
pub type int_fast64_t = int64_t;
pub type uint_fast8_t = uint8_t;
pub type uint_fast16_t = uint16_t;
pub type uint_fast32_t = uint32_t;
pub type uint_fast64_t = uint64_t;
pub type intptr_t = __darwin_intptr_t;
pub type uintptr_t = ::libc::c_ulong;
pub type intmax_t = ::libc::c_long;
pub type uintmax_t = ::libc::c_ulong;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
impl ::std::clone::Clone for Struct_timeval {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_timeval {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rlim_t = __uint64_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rusage {
    pub ru_utime: Struct_timeval,
    pub ru_stime: Struct_timeval,
    pub ru_maxrss: ::libc::c_long,
    pub ru_ixrss: ::libc::c_long,
    pub ru_idrss: ::libc::c_long,
    pub ru_isrss: ::libc::c_long,
    pub ru_minflt: ::libc::c_long,
    pub ru_majflt: ::libc::c_long,
    pub ru_nswap: ::libc::c_long,
    pub ru_inblock: ::libc::c_long,
    pub ru_oublock: ::libc::c_long,
    pub ru_msgsnd: ::libc::c_long,
    pub ru_msgrcv: ::libc::c_long,
    pub ru_nsignals: ::libc::c_long,
    pub ru_nvcsw: ::libc::c_long,
    pub ru_nivcsw: ::libc::c_long,
}
impl ::std::clone::Clone for Struct_rusage {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rusage {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rusage_info_t = *mut ::libc::c_void;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rusage_info_v0 {
    pub ri_uuid: [uint8_t; 16usize],
    pub ri_user_time: uint64_t,
    pub ri_system_time: uint64_t,
    pub ri_pkg_idle_wkups: uint64_t,
    pub ri_interrupt_wkups: uint64_t,
    pub ri_pageins: uint64_t,
    pub ri_wired_size: uint64_t,
    pub ri_resident_size: uint64_t,
    pub ri_phys_footprint: uint64_t,
    pub ri_proc_start_abstime: uint64_t,
    pub ri_proc_exit_abstime: uint64_t,
}
impl ::std::clone::Clone for Struct_rusage_info_v0 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rusage_info_v0 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rusage_info_v1 {
    pub ri_uuid: [uint8_t; 16usize],
    pub ri_user_time: uint64_t,
    pub ri_system_time: uint64_t,
    pub ri_pkg_idle_wkups: uint64_t,
    pub ri_interrupt_wkups: uint64_t,
    pub ri_pageins: uint64_t,
    pub ri_wired_size: uint64_t,
    pub ri_resident_size: uint64_t,
    pub ri_phys_footprint: uint64_t,
    pub ri_proc_start_abstime: uint64_t,
    pub ri_proc_exit_abstime: uint64_t,
    pub ri_child_user_time: uint64_t,
    pub ri_child_system_time: uint64_t,
    pub ri_child_pkg_idle_wkups: uint64_t,
    pub ri_child_interrupt_wkups: uint64_t,
    pub ri_child_pageins: uint64_t,
    pub ri_child_elapsed_abstime: uint64_t,
}
impl ::std::clone::Clone for Struct_rusage_info_v1 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rusage_info_v1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rusage_info_v2 {
    pub ri_uuid: [uint8_t; 16usize],
    pub ri_user_time: uint64_t,
    pub ri_system_time: uint64_t,
    pub ri_pkg_idle_wkups: uint64_t,
    pub ri_interrupt_wkups: uint64_t,
    pub ri_pageins: uint64_t,
    pub ri_wired_size: uint64_t,
    pub ri_resident_size: uint64_t,
    pub ri_phys_footprint: uint64_t,
    pub ri_proc_start_abstime: uint64_t,
    pub ri_proc_exit_abstime: uint64_t,
    pub ri_child_user_time: uint64_t,
    pub ri_child_system_time: uint64_t,
    pub ri_child_pkg_idle_wkups: uint64_t,
    pub ri_child_interrupt_wkups: uint64_t,
    pub ri_child_pageins: uint64_t,
    pub ri_child_elapsed_abstime: uint64_t,
    pub ri_diskio_bytesread: uint64_t,
    pub ri_diskio_byteswritten: uint64_t,
}
impl ::std::clone::Clone for Struct_rusage_info_v2 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rusage_info_v2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
impl ::std::clone::Clone for Struct_rlimit {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rlimit {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_proc_rlimit_control_wakeupmon {
    pub wm_flags: uint32_t,
    pub wm_rate: int32_t,
}
impl ::std::clone::Clone for Struct_proc_rlimit_control_wakeupmon {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_proc_rlimit_control_wakeupmon {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_wait {
    pub _bindgen_data_: [u32; 1usize],
}
impl Union_wait {
    pub unsafe fn w_status(&mut self) -> *mut ::libc::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn w_T(&mut self) -> *mut Struct_Unnamed3 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn w_S(&mut self) -> *mut Struct_Unnamed4 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_wait {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_wait {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed3 {
    pub _bindgen_bitfield_1_: ::libc::c_uint,
}
impl ::std::clone::Clone for Struct_Unnamed3 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed3 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed4 {
    pub _bindgen_bitfield_1_: ::libc::c_uint,
}
impl ::std::clone::Clone for Struct_Unnamed4 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed4 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ct_rune_t = __darwin_ct_rune_t;
pub type rune_t = __darwin_rune_t;
pub type wchar_t = __darwin_wchar_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed5 {
    pub quot: ::libc::c_int,
    pub rem: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_Unnamed5 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed5 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type div_t = Struct_Unnamed5;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed6 {
    pub quot: ::libc::c_long,
    pub rem: ::libc::c_long,
}
impl ::std::clone::Clone for Struct_Unnamed6 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed6 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ldiv_t = Struct_Unnamed6;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed7 {
    pub quot: ::libc::c_longlong,
    pub rem: ::libc::c_longlong,
}
impl ::std::clone::Clone for Struct_Unnamed7 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed7 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type lldiv_t = Struct_Unnamed7;
pub type u_int8_t = ::libc::c_uchar;
pub type u_int16_t = ::libc::c_ushort;
pub type u_int32_t = ::libc::c_uint;
pub type u_int64_t = ::libc::c_ulonglong;
pub type register_t = int64_t;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = int64_t;
pub type user_long_t = int64_t;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = int64_t;
pub type user_off_t = int64_t;
pub type syscall_arg_t = u_int64_t;
pub type dev_t = __darwin_dev_t;
pub type mode_t = __darwin_mode_t;
pub type rsize_t = __darwin_size_t;
pub type errno_t = ::libc::c_int;
pub type ptrdiff_t = ::libc::c_long;
pub type __gnuc_va_list = __builtin_va_list;
pub type u_char = ::libc::c_uchar;
pub type u_short = ::libc::c_ushort;
pub type u_int = ::libc::c_uint;
pub type u_long = ::libc::c_ulong;
pub type ushort = ::libc::c_ushort;
pub type _uint = ::libc::c_uint;
pub type u_quad_t = u_int64_t;
pub type quad_t = int64_t;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::libc::c_char;
pub type daddr_t = int32_t;
pub type fixpt_t = u_int32_t;
pub type blkcnt_t = __darwin_blkcnt_t;
pub type blksize_t = __darwin_blksize_t;
pub type gid_t = __darwin_gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type ino_t = __darwin_ino_t;
pub type ino64_t = __darwin_ino64_t;
pub type key_t = __int32_t;
pub type nlink_t = __uint16_t;
pub type segsz_t = int32_t;
pub type swblk_t = int32_t;
pub type clock_t = __darwin_clock_t;
pub type time_t = __darwin_time_t;
pub type useconds_t = __darwin_useconds_t;
pub type suseconds_t = __darwin_suseconds_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_fd_set {
    pub fds_bits: [__int32_t; 32usize],
}
impl ::std::clone::Clone for Struct_fd_set {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_fd_set {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type fd_set = Struct_fd_set;
pub type fd_mask = __int32_t;
pub type pthread_cond_t = __darwin_pthread_cond_t;
pub type pthread_condattr_t = __darwin_pthread_condattr_t;
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_mutexattr_t = __darwin_pthread_mutexattr_t;
pub type pthread_once_t = __darwin_pthread_once_t;
pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub type pthread_rwlockattr_t = __darwin_pthread_rwlockattr_t;
pub type pthread_t = __darwin_pthread_t;
pub type pthread_key_t = __darwin_pthread_key_t;
pub type fsblkcnt_t = __darwin_fsblkcnt_t;
pub type fsfilcnt_t = __darwin_fsfilcnt_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_lconv {
    pub decimal_point: *mut ::libc::c_char,
    pub thousands_sep: *mut ::libc::c_char,
    pub grouping: *mut ::libc::c_char,
    pub int_curr_symbol: *mut ::libc::c_char,
    pub currency_symbol: *mut ::libc::c_char,
    pub mon_decimal_point: *mut ::libc::c_char,
    pub mon_thousands_sep: *mut ::libc::c_char,
    pub mon_grouping: *mut ::libc::c_char,
    pub positive_sign: *mut ::libc::c_char,
    pub negative_sign: *mut ::libc::c_char,
    pub int_frac_digits: ::libc::c_char,
    pub frac_digits: ::libc::c_char,
    pub p_cs_precedes: ::libc::c_char,
    pub p_sep_by_space: ::libc::c_char,
    pub n_cs_precedes: ::libc::c_char,
    pub n_sep_by_space: ::libc::c_char,
    pub p_sign_posn: ::libc::c_char,
    pub n_sign_posn: ::libc::c_char,
    pub int_p_cs_precedes: ::libc::c_char,
    pub int_n_cs_precedes: ::libc::c_char,
    pub int_p_sep_by_space: ::libc::c_char,
    pub int_n_sep_by_space: ::libc::c_char,
    pub int_p_sign_posn: ::libc::c_char,
    pub int_n_sign_posn: ::libc::c_char,
}
impl ::std::clone::Clone for Struct_lconv {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_lconv {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type _bool = ::libc::c_char;
pub type BoolPtr = *mut _bool;
pub type Pointer = *mut ::libc::c_char;
pub type int8 = ::libc::c_char;
pub type int16 = ::libc::c_short;
pub type int32 = ::libc::c_int;
pub type uint8 = ::libc::c_uchar;
pub type uint16 = ::libc::c_ushort;
pub type uint32 = ::libc::c_uint;
pub type bits8 = uint8;
pub type bits16 = uint16;
pub type bits32 = uint32;
pub type int64 = ::libc::c_long;
pub type uint64 = ::libc::c_ulong;
pub type Size = size_t;
pub type Index = ::libc::c_uint;
pub type Offset = ::libc::c_int;
pub type float4 = ::libc::c_float;
pub type float8 = ::libc::c_double;
pub type regproc = Oid;
pub type RegProcedure = regproc;
pub type TransactionId = uint32;
pub type LocalTransactionId = uint32;
pub type SubTransactionId = uint32;
pub type MultiXactId = TransactionId;
pub type MultiXactOffset = uint32;
pub type CommandId = uint32;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed8 {
    pub indx: [::libc::c_int; 6usize],
}
impl ::std::clone::Clone for Struct_Unnamed8 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed8 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type IntArray = Struct_Unnamed8;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_varlena {
    pub vl_len_: [::libc::c_char; 4usize],
    pub vl_dat: [::libc::c_char; 1usize],
}
impl ::std::clone::Clone for Struct_varlena {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_varlena {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type bytea = Struct_varlena;
pub type text = Struct_varlena;
pub type BpChar = Struct_varlena;
pub type VarChar = Struct_varlena;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed9 {
    pub vl_len_: int32,
    pub ndim: ::libc::c_int,
    pub dataoffset: int32,
    pub elemtype: Oid,
    pub dim1: ::libc::c_int,
    pub lbound1: ::libc::c_int,
    pub values: [int16; 1usize],
}
impl ::std::clone::Clone for Struct_Unnamed9 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed9 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type int2vector = Struct_Unnamed9;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed10 {
    pub vl_len_: int32,
    pub ndim: ::libc::c_int,
    pub dataoffset: int32,
    pub elemtype: Oid,
    pub dim1: ::libc::c_int,
    pub lbound1: ::libc::c_int,
    pub values: [Oid; 1usize],
}
impl ::std::clone::Clone for Struct_Unnamed10 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed10 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type oidvector = Struct_Unnamed10;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_nameData {
    pub data: [::libc::c_char; 64usize],
}
impl ::std::clone::Clone for Struct_nameData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_nameData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type NameData = Struct_nameData;
pub type Name = *mut NameData;
pub type wint_t = __darwin_wint_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed11 {
    pub __min: __darwin_rune_t,
    pub __max: __darwin_rune_t,
    pub __map: __darwin_rune_t,
    pub __types: *mut __uint32_t,
}
impl ::std::clone::Clone for Struct_Unnamed11 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed11 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type _RuneEntry = Struct_Unnamed11;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed12 {
    pub __nranges: ::libc::c_int,
    pub __ranges: *mut _RuneEntry,
}
impl ::std::clone::Clone for Struct_Unnamed12 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed12 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type _RuneRange = Struct_Unnamed12;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed13 {
    pub __name: [::libc::c_char; 14usize],
    pub __mask: __uint32_t,
}
impl ::std::clone::Clone for Struct_Unnamed13 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed13 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type _RuneCharClass = Struct_Unnamed13;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed14 {
    pub __magic: [::libc::c_char; 8usize],
    pub __encoding: [::libc::c_char; 32usize],
    pub __sgetrune: ::std::option::Option<extern "C" fn(arg1:
                                                            *const ::libc::c_char,
                                                        arg2: __darwin_size_t,
                                                        arg3:
                                                            *mut *const ::libc::c_char)
                                              -> __darwin_rune_t>,
    pub __sputrune: ::std::option::Option<extern "C" fn(arg1: __darwin_rune_t,
                                                        arg2:
                                                            *mut ::libc::c_char,
                                                        arg3: __darwin_size_t,
                                                        arg4:
                                                            *mut *mut ::libc::c_char)
                                              -> ::libc::c_int>,
    pub __invalid_rune: __darwin_rune_t,
    pub __runetype: [__uint32_t; 256usize],
    pub __maplower: [__darwin_rune_t; 256usize],
    pub __mapupper: [__darwin_rune_t; 256usize],
    pub __runetype_ext: _RuneRange,
    pub __maplower_ext: _RuneRange,
    pub __mapupper_ext: _RuneRange,
    pub __variable: *mut ::libc::c_void,
    pub __variable_len: ::libc::c_int,
    pub __ncharclasses: ::libc::c_int,
    pub __charclasses: *mut _RuneCharClass,
}
impl ::std::clone::Clone for Struct_Unnamed14 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed14 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type _RuneLocale = Struct_Unnamed14;
pub type socklen_t = __darwin_socklen_t;
pub type sa_family_t = __uint8_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_iovec {
    pub iov_base: *mut ::libc::c_void,
    pub iov_len: size_t,
}
impl ::std::clone::Clone for Struct_iovec {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_iovec {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_linger {
    pub l_onoff: ::libc::c_int,
    pub l_linger: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_linger {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_linger {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_so_np_extensions {
    pub npx_flags: u_int32_t,
    pub npx_mask: u_int32_t,
}
impl ::std::clone::Clone for Struct_so_np_extensions {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_so_np_extensions {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sockaddr {
    pub sa_len: __uint8_t,
    pub sa_family: sa_family_t,
    pub sa_data: [::libc::c_char; 14usize],
}
impl ::std::clone::Clone for Struct_sockaddr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sockaddr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sockproto {
    pub sp_family: __uint16_t,
    pub sp_protocol: __uint16_t,
}
impl ::std::clone::Clone for Struct_sockproto {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sockproto {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sockaddr_storage {
    pub ss_len: __uint8_t,
    pub ss_family: sa_family_t,
    pub __ss_pad1: [::libc::c_char; 6usize],
    pub __ss_align: __int64_t,
    pub __ss_pad2: [::libc::c_char; 112usize],
}
impl ::std::clone::Clone for Struct_sockaddr_storage {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sockaddr_storage {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_msghdr {
    pub msg_name: *mut ::libc::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut Struct_iovec,
    pub msg_iovlen: ::libc::c_int,
    pub msg_control: *mut ::libc::c_void,
    pub msg_controllen: socklen_t,
    pub msg_flags: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_msghdr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_msghdr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_cmsghdr {
    pub cmsg_len: socklen_t,
    pub cmsg_level: ::libc::c_int,
    pub cmsg_type: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_cmsghdr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_cmsghdr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sf_hdtr {
    pub headers: *mut Struct_iovec,
    pub hdr_cnt: ::libc::c_int,
    pub trailers: *mut Struct_iovec,
    pub trl_cnt: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_sf_hdtr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sf_hdtr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_in_addr {
    pub s_addr: in_addr_t,
}
impl ::std::clone::Clone for Struct_in_addr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_in_addr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sockaddr_in {
    pub sin_len: __uint8_t,
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: Struct_in_addr,
    pub sin_zero: [::libc::c_char; 8usize],
}
impl ::std::clone::Clone for Struct_sockaddr_in {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sockaddr_in {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ip_opts {
    pub ip_dst: Struct_in_addr,
    pub ip_opts: [::libc::c_char; 40usize],
}
impl ::std::clone::Clone for Struct_ip_opts {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ip_opts {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ip_mreq {
    pub imr_multiaddr: Struct_in_addr,
    pub imr_interface: Struct_in_addr,
}
impl ::std::clone::Clone for Struct_ip_mreq {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ip_mreq {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ip_mreqn {
    pub imr_multiaddr: Struct_in_addr,
    pub imr_address: Struct_in_addr,
    pub imr_ifindex: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_ip_mreqn {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ip_mreqn {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ip_mreq_source {
    pub imr_multiaddr: Struct_in_addr,
    pub imr_sourceaddr: Struct_in_addr,
    pub imr_interface: Struct_in_addr,
}
impl ::std::clone::Clone for Struct_ip_mreq_source {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ip_mreq_source {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_group_req {
    pub gr_interface: uint32_t,
    pub gr_group: Struct_sockaddr_storage,
}
impl ::std::clone::Clone for Struct_group_req {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_group_req {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_group_source_req {
    pub gsr_interface: uint32_t,
    pub gsr_group: Struct_sockaddr_storage,
    pub gsr_source: Struct_sockaddr_storage,
}
impl ::std::clone::Clone for Struct_group_source_req {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_group_source_req {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___msfilterreq {
    pub msfr_ifindex: uint32_t,
    pub msfr_fmode: uint32_t,
    pub msfr_nsrcs: uint32_t,
    pub __msfr_align: uint32_t,
    pub msfr_group: Struct_sockaddr_storage,
    pub msfr_srcs: *mut Struct_sockaddr_storage,
}
impl ::std::clone::Clone for Struct___msfilterreq {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___msfilterreq {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_in_pktinfo {
    pub ipi_ifindex: ::libc::c_uint,
    pub ipi_spec_dst: Struct_in_addr,
    pub ipi_addr: Struct_in_addr,
}
impl ::std::clone::Clone for Struct_in_pktinfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_in_pktinfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_in6_addr {
    pub __u6_addr: Union_Unnamed15,
}
impl ::std::clone::Clone for Struct_in6_addr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_in6_addr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed15 {
    pub _bindgen_data_: [u32; 4usize],
}
impl Union_Unnamed15 {
    pub unsafe fn __u6_addr8(&mut self) -> *mut [__uint8_t; 16usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __u6_addr16(&mut self) -> *mut [__uint16_t; 8usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __u6_addr32(&mut self) -> *mut [__uint32_t; 4usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed15 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed15 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sockaddr_in6 {
    pub sin6_len: __uint8_t,
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: __uint32_t,
    pub sin6_addr: Struct_in6_addr,
    pub sin6_scope_id: __uint32_t,
}
impl ::std::clone::Clone for Struct_sockaddr_in6 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sockaddr_in6 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ipv6_mreq {
    pub ipv6mr_multiaddr: Struct_in6_addr,
    pub ipv6mr_interface: ::libc::c_uint,
}
impl ::std::clone::Clone for Struct_ipv6_mreq {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ipv6_mreq {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_in6_pktinfo {
    pub ipi6_addr: Struct_in6_addr,
    pub ipi6_ifindex: ::libc::c_uint,
}
impl ::std::clone::Clone for Struct_in6_pktinfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_in6_pktinfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ip6_mtuinfo {
    pub ip6m_addr: Struct_sockaddr_in6,
    pub ip6m_mtu: uint32_t,
}
impl ::std::clone::Clone for Struct_ip6_mtuinfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ip6_mtuinfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_hostent {
    pub h_name: *mut ::libc::c_char,
    pub h_aliases: *mut *mut ::libc::c_char,
    pub h_addrtype: ::libc::c_int,
    pub h_length: ::libc::c_int,
    pub h_addr_list: *mut *mut ::libc::c_char,
}
impl ::std::clone::Clone for Struct_hostent {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_hostent {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_netent {
    pub n_name: *mut ::libc::c_char,
    pub n_aliases: *mut *mut ::libc::c_char,
    pub n_addrtype: ::libc::c_int,
    pub n_net: uint32_t,
}
impl ::std::clone::Clone for Struct_netent {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_netent {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_servent {
    pub s_name: *mut ::libc::c_char,
    pub s_aliases: *mut *mut ::libc::c_char,
    pub s_port: ::libc::c_int,
    pub s_proto: *mut ::libc::c_char,
}
impl ::std::clone::Clone for Struct_servent {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_servent {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_protoent {
    pub p_name: *mut ::libc::c_char,
    pub p_aliases: *mut *mut ::libc::c_char,
    pub p_proto: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_protoent {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_protoent {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_addrinfo {
    pub ai_flags: ::libc::c_int,
    pub ai_family: ::libc::c_int,
    pub ai_socktype: ::libc::c_int,
    pub ai_protocol: ::libc::c_int,
    pub ai_addrlen: socklen_t,
    pub ai_canonname: *mut ::libc::c_char,
    pub ai_addr: *mut Struct_sockaddr,
    pub ai_next: *mut Struct_addrinfo,
}
impl ::std::clone::Clone for Struct_addrinfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_addrinfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rpcent {
    pub r_name: *mut ::libc::c_char,
    pub r_aliases: *mut *mut ::libc::c_char,
    pub r_number: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_rpcent {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rpcent {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_passwd {
    pub pw_name: *mut ::libc::c_char,
    pub pw_passwd: *mut ::libc::c_char,
    pub pw_uid: uid_t,
    pub pw_gid: gid_t,
    pub pw_change: __darwin_time_t,
    pub pw_class: *mut ::libc::c_char,
    pub pw_gecos: *mut ::libc::c_char,
    pub pw_dir: *mut ::libc::c_char,
    pub pw_shell: *mut ::libc::c_char,
    pub pw_expire: __darwin_time_t,
}
impl ::std::clone::Clone for Struct_passwd {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_passwd {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type uuid_t = __darwin_uuid_t;
pub type uuid_string_t = __darwin_uuid_string_t;
pub type pgsocket = ::libc::c_int;
pub type qsort_arg_comparator =
    ::std::option::Option<extern "C" fn(a: *const ::libc::c_void,
                                        b: *const ::libc::c_void,
                                        arg: *mut ::libc::c_void)
                              -> ::libc::c_int>;
pub type pqsigfunc =
    ::std::option::Option<extern "C" fn(signo: ::libc::c_int) -> ()>;
pub type jmp_buf = [::libc::c_int; 37usize];
pub type sigjmp_buf = [::libc::c_int; 38usize];
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ErrorContextCallback {
    pub previous: *mut Struct_ErrorContextCallback,
    pub callback: ::std::option::Option<extern "C" fn(arg:
                                                          *mut ::libc::c_void)
                                            -> ()>,
    pub arg: *mut ::libc::c_void,
}
impl ::std::clone::Clone for Struct_ErrorContextCallback {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ErrorContextCallback {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ErrorContextCallback = Struct_ErrorContextCallback;
pub enum Struct_MemoryContextData { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ErrorData {
    pub elevel: ::libc::c_int,
    pub output_to_server: _bool,
    pub output_to_client: _bool,
    pub show_funcname: _bool,
    pub hide_stmt: _bool,
    pub filename: *const ::libc::c_char,
    pub lineno: ::libc::c_int,
    pub funcname: *const ::libc::c_char,
    pub domain: *const ::libc::c_char,
    pub context_domain: *const ::libc::c_char,
    pub sqlerrcode: ::libc::c_int,
    pub message: *mut ::libc::c_char,
    pub detail: *mut ::libc::c_char,
    pub detail_log: *mut ::libc::c_char,
    pub hint: *mut ::libc::c_char,
    pub context: *mut ::libc::c_char,
    pub schema_name: *mut ::libc::c_char,
    pub table_name: *mut ::libc::c_char,
    pub column_name: *mut ::libc::c_char,
    pub datatype_name: *mut ::libc::c_char,
    pub constraint_name: *mut ::libc::c_char,
    pub cursorpos: ::libc::c_int,
    pub internalpos: ::libc::c_int,
    pub internalquery: *mut ::libc::c_char,
    pub saved_errno: ::libc::c_int,
    pub assoc_context: *mut Struct_MemoryContextData,
}
impl ::std::clone::Clone for Struct_ErrorData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ErrorData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ErrorData = Struct_ErrorData;
pub type emit_log_hook_type =
    ::std::option::Option<extern "C" fn(edata: *mut ErrorData) -> ()>;
pub type Enum_Unnamed16 = ::libc::c_uint;
pub const PGERROR_TERSE: ::libc::c_uint = 0;
pub const PGERROR_DEFAULT: ::libc::c_uint = 1;
pub const PGERROR_VERBOSE: ::libc::c_uint = 2;
pub type PGErrorVerbosity = Enum_Unnamed16;
pub type MemoryContext = *mut Struct_MemoryContextData;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_varatt_external {
    pub va_rawsize: int32,
    pub va_extsize: int32,
    pub va_valueid: Oid,
    pub va_toastrelid: Oid,
}
impl ::std::clone::Clone for Struct_varatt_external {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_varatt_external {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type varatt_external = Struct_varatt_external;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_varatt_indirect {
    pub pointer: *mut Struct_varlena,
}
impl ::std::clone::Clone for Struct_varatt_indirect {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_varatt_indirect {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type varatt_indirect = Struct_varatt_indirect;
pub type Enum_vartag_external = ::libc::c_uint;
pub const VARTAG_INDIRECT: ::libc::c_uint = 1;
pub const VARTAG_ONDISK: ::libc::c_uint = 18;
pub type vartag_external = Enum_vartag_external;
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed17 {
    pub _bindgen_data_: [u32; 3usize],
}
impl Union_Unnamed17 {
    pub unsafe fn va_4byte(&mut self) -> *mut Struct_Unnamed18 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn va_compressed(&mut self) -> *mut Struct_Unnamed19 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed17 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed17 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed18 {
    pub va_header: uint32,
    pub va_data: [::libc::c_char; 1usize],
}
impl ::std::clone::Clone for Struct_Unnamed18 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed18 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed19 {
    pub va_header: uint32,
    pub va_rawsize: uint32,
    pub va_data: [::libc::c_char; 1usize],
}
impl ::std::clone::Clone for Struct_Unnamed19 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed19 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type varattrib_4b = Union_Unnamed17;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed20 {
    pub va_header: uint8,
    pub va_data: [::libc::c_char; 1usize],
}
impl ::std::clone::Clone for Struct_Unnamed20 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed20 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type varattrib_1b = Struct_Unnamed20;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed21 {
    pub va_header: uint8,
    pub va_tag: uint8,
    pub va_data: [::libc::c_char; 1usize],
}
impl ::std::clone::Clone for Struct_Unnamed21 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed21 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type varattrib_1b_e = Struct_Unnamed21;
pub type Datum = uintptr_t;
pub type DatumPtr = *mut Datum;
pub type BlockNumber = uint32;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_BlockIdData {
    pub bi_hi: uint16,
    pub bi_lo: uint16,
}
impl ::std::clone::Clone for Struct_BlockIdData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_BlockIdData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type BlockIdData = Struct_BlockIdData;
pub type BlockId = *mut BlockIdData;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ItemIdData {
    pub _bindgen_bitfield_1_: ::libc::c_uint,
}
impl ::std::clone::Clone for Struct_ItemIdData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ItemIdData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ItemIdData = Struct_ItemIdData;
pub type ItemId = *mut ItemIdData;
pub type ItemOffset = uint16;
pub type ItemLength = uint16;
pub type OffsetNumber = uint16;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ItemPointerData {
    pub ip_blkid: BlockIdData,
    pub ip_posid: OffsetNumber,
}
impl ::std::clone::Clone for Struct_ItemPointerData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ItemPointerData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ItemPointerData = Struct_ItemPointerData;
pub type ItemPointer = *mut ItemPointerData;
pub type HeapTupleHeaderData = Struct_HeapTupleHeaderData;
pub type HeapTupleHeader = *mut HeapTupleHeaderData;
pub type MinimalTupleData = Struct_MinimalTupleData;
pub type MinimalTuple = *mut MinimalTupleData;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_HeapTupleData {
    pub t_len: uint32,
    pub t_self: ItemPointerData,
    pub t_tableOid: Oid,
    pub t_data: HeapTupleHeader,
}
impl ::std::clone::Clone for Struct_HeapTupleData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_HeapTupleData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HeapTupleData = Struct_HeapTupleData;
pub type HeapTuple = *mut HeapTupleData;
pub type AttrNumber = int16;
pub type aclitem = ::libc::c_int;
pub type pg_node_tree = ::libc::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_FormData_pg_attribute {
    pub attrelid: Oid,
    pub attname: NameData,
    pub atttypid: Oid,
    pub attstattarget: int32,
    pub attlen: int16,
    pub attnum: int16,
    pub attndims: int32,
    pub attcacheoff: int32,
    pub atttypmod: int32,
    pub attbyval: _bool,
    pub attstorage: ::libc::c_char,
    pub attalign: ::libc::c_char,
    pub attnotnull: _bool,
    pub atthasdef: _bool,
    pub attisdropped: _bool,
    pub attislocal: _bool,
    pub attinhcount: int32,
    pub attcollation: Oid,
}
impl ::std::clone::Clone for Struct_FormData_pg_attribute {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_FormData_pg_attribute {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FormData_pg_attribute = Struct_FormData_pg_attribute;
pub type Form_pg_attribute = *mut FormData_pg_attribute;
pub type Enum_NodeTag = ::libc::c_uint;
pub const T_Invalid: ::libc::c_uint = 0;
pub const T_IndexInfo: ::libc::c_uint = 10;
pub const T_ExprContext: ::libc::c_uint = 11;
pub const T_ProjectionInfo: ::libc::c_uint = 12;
pub const T_JunkFilter: ::libc::c_uint = 13;
pub const T_ResultRelInfo: ::libc::c_uint = 14;
pub const T_EState: ::libc::c_uint = 15;
pub const T_TupleTableSlot: ::libc::c_uint = 16;
pub const T_Plan: ::libc::c_uint = 100;
pub const T_Result: ::libc::c_uint = 101;
pub const T_ModifyTable: ::libc::c_uint = 102;
pub const T_Append: ::libc::c_uint = 103;
pub const T_MergeAppend: ::libc::c_uint = 104;
pub const T_RecursiveUnion: ::libc::c_uint = 105;
pub const T_BitmapAnd: ::libc::c_uint = 106;
pub const T_BitmapOr: ::libc::c_uint = 107;
pub const T_Scan: ::libc::c_uint = 108;
pub const T_SeqScan: ::libc::c_uint = 109;
pub const T_IndexScan: ::libc::c_uint = 110;
pub const T_IndexOnlyScan: ::libc::c_uint = 111;
pub const T_BitmapIndexScan: ::libc::c_uint = 112;
pub const T_BitmapHeapScan: ::libc::c_uint = 113;
pub const T_TidScan: ::libc::c_uint = 114;
pub const T_SubqueryScan: ::libc::c_uint = 115;
pub const T_FunctionScan: ::libc::c_uint = 116;
pub const T_ValuesScan: ::libc::c_uint = 117;
pub const T_CteScan: ::libc::c_uint = 118;
pub const T_WorkTableScan: ::libc::c_uint = 119;
pub const T_ForeignScan: ::libc::c_uint = 120;
pub const T_Join: ::libc::c_uint = 121;
pub const T_NestLoop: ::libc::c_uint = 122;
pub const T_MergeJoin: ::libc::c_uint = 123;
pub const T_HashJoin: ::libc::c_uint = 124;
pub const T_Material: ::libc::c_uint = 125;
pub const T_Sort: ::libc::c_uint = 126;
pub const T_Group: ::libc::c_uint = 127;
pub const T_Agg: ::libc::c_uint = 128;
pub const T_WindowAgg: ::libc::c_uint = 129;
pub const T_Unique: ::libc::c_uint = 130;
pub const T_Hash: ::libc::c_uint = 131;
pub const T_SetOp: ::libc::c_uint = 132;
pub const T_LockRows: ::libc::c_uint = 133;
pub const T_Limit: ::libc::c_uint = 134;
pub const T_NestLoopParam: ::libc::c_uint = 135;
pub const T_PlanRowMark: ::libc::c_uint = 136;
pub const T_PlanInvalItem: ::libc::c_uint = 137;
pub const T_PlanState: ::libc::c_uint = 200;
pub const T_ResultState: ::libc::c_uint = 201;
pub const T_ModifyTableState: ::libc::c_uint = 202;
pub const T_AppendState: ::libc::c_uint = 203;
pub const T_MergeAppendState: ::libc::c_uint = 204;
pub const T_RecursiveUnionState: ::libc::c_uint = 205;
pub const T_BitmapAndState: ::libc::c_uint = 206;
pub const T_BitmapOrState: ::libc::c_uint = 207;
pub const T_ScanState: ::libc::c_uint = 208;
pub const T_SeqScanState: ::libc::c_uint = 209;
pub const T_IndexScanState: ::libc::c_uint = 210;
pub const T_IndexOnlyScanState: ::libc::c_uint = 211;
pub const T_BitmapIndexScanState: ::libc::c_uint = 212;
pub const T_BitmapHeapScanState: ::libc::c_uint = 213;
pub const T_TidScanState: ::libc::c_uint = 214;
pub const T_SubqueryScanState: ::libc::c_uint = 215;
pub const T_FunctionScanState: ::libc::c_uint = 216;
pub const T_ValuesScanState: ::libc::c_uint = 217;
pub const T_CteScanState: ::libc::c_uint = 218;
pub const T_WorkTableScanState: ::libc::c_uint = 219;
pub const T_ForeignScanState: ::libc::c_uint = 220;
pub const T_JoinState: ::libc::c_uint = 221;
pub const T_NestLoopState: ::libc::c_uint = 222;
pub const T_MergeJoinState: ::libc::c_uint = 223;
pub const T_HashJoinState: ::libc::c_uint = 224;
pub const T_MaterialState: ::libc::c_uint = 225;
pub const T_SortState: ::libc::c_uint = 226;
pub const T_GroupState: ::libc::c_uint = 227;
pub const T_AggState: ::libc::c_uint = 228;
pub const T_WindowAggState: ::libc::c_uint = 229;
pub const T_UniqueState: ::libc::c_uint = 230;
pub const T_HashState: ::libc::c_uint = 231;
pub const T_SetOpState: ::libc::c_uint = 232;
pub const T_LockRowsState: ::libc::c_uint = 233;
pub const T_LimitState: ::libc::c_uint = 234;
pub const T_Alias: ::libc::c_uint = 300;
pub const T_RangeVar: ::libc::c_uint = 301;
pub const T_Expr: ::libc::c_uint = 302;
pub const T_Var: ::libc::c_uint = 303;
pub const T_Const: ::libc::c_uint = 304;
pub const T_Param: ::libc::c_uint = 305;
pub const T_Aggref: ::libc::c_uint = 306;
pub const T_WindowFunc: ::libc::c_uint = 307;
pub const T_ArrayRef: ::libc::c_uint = 308;
pub const T_FuncExpr: ::libc::c_uint = 309;
pub const T_NamedArgExpr: ::libc::c_uint = 310;
pub const T_OpExpr: ::libc::c_uint = 311;
pub const T_DistinctExpr: ::libc::c_uint = 312;
pub const T_NullIfExpr: ::libc::c_uint = 313;
pub const T_ScalarArrayOpExpr: ::libc::c_uint = 314;
pub const T_BoolExpr: ::libc::c_uint = 315;
pub const T_SubLink: ::libc::c_uint = 316;
pub const T_SubPlan: ::libc::c_uint = 317;
pub const T_AlternativeSubPlan: ::libc::c_uint = 318;
pub const T_FieldSelect: ::libc::c_uint = 319;
pub const T_FieldStore: ::libc::c_uint = 320;
pub const T_RelabelType: ::libc::c_uint = 321;
pub const T_CoerceViaIO: ::libc::c_uint = 322;
pub const T_ArrayCoerceExpr: ::libc::c_uint = 323;
pub const T_ConvertRowtypeExpr: ::libc::c_uint = 324;
pub const T_CollateExpr: ::libc::c_uint = 325;
pub const T_CaseExpr: ::libc::c_uint = 326;
pub const T_CaseWhen: ::libc::c_uint = 327;
pub const T_CaseTestExpr: ::libc::c_uint = 328;
pub const T_ArrayExpr: ::libc::c_uint = 329;
pub const T_RowExpr: ::libc::c_uint = 330;
pub const T_RowCompareExpr: ::libc::c_uint = 331;
pub const T_CoalesceExpr: ::libc::c_uint = 332;
pub const T_MinMaxExpr: ::libc::c_uint = 333;
pub const T_XmlExpr: ::libc::c_uint = 334;
pub const T_NullTest: ::libc::c_uint = 335;
pub const T_BooleanTest: ::libc::c_uint = 336;
pub const T_CoerceToDomain: ::libc::c_uint = 337;
pub const T_CoerceToDomainValue: ::libc::c_uint = 338;
pub const T_SetToDefault: ::libc::c_uint = 339;
pub const T_CurrentOfExpr: ::libc::c_uint = 340;
pub const T_TargetEntry: ::libc::c_uint = 341;
pub const T_RangeTblRef: ::libc::c_uint = 342;
pub const T_JoinExpr: ::libc::c_uint = 343;
pub const T_FromExpr: ::libc::c_uint = 344;
pub const T_IntoClause: ::libc::c_uint = 345;
pub const T_ExprState: ::libc::c_uint = 400;
pub const T_GenericExprState: ::libc::c_uint = 401;
pub const T_WholeRowVarExprState: ::libc::c_uint = 402;
pub const T_AggrefExprState: ::libc::c_uint = 403;
pub const T_WindowFuncExprState: ::libc::c_uint = 404;
pub const T_ArrayRefExprState: ::libc::c_uint = 405;
pub const T_FuncExprState: ::libc::c_uint = 406;
pub const T_ScalarArrayOpExprState: ::libc::c_uint = 407;
pub const T_BoolExprState: ::libc::c_uint = 408;
pub const T_SubPlanState: ::libc::c_uint = 409;
pub const T_AlternativeSubPlanState: ::libc::c_uint = 410;
pub const T_FieldSelectState: ::libc::c_uint = 411;
pub const T_FieldStoreState: ::libc::c_uint = 412;
pub const T_CoerceViaIOState: ::libc::c_uint = 413;
pub const T_ArrayCoerceExprState: ::libc::c_uint = 414;
pub const T_ConvertRowtypeExprState: ::libc::c_uint = 415;
pub const T_CaseExprState: ::libc::c_uint = 416;
pub const T_CaseWhenState: ::libc::c_uint = 417;
pub const T_ArrayExprState: ::libc::c_uint = 418;
pub const T_RowExprState: ::libc::c_uint = 419;
pub const T_RowCompareExprState: ::libc::c_uint = 420;
pub const T_CoalesceExprState: ::libc::c_uint = 421;
pub const T_MinMaxExprState: ::libc::c_uint = 422;
pub const T_XmlExprState: ::libc::c_uint = 423;
pub const T_NullTestState: ::libc::c_uint = 424;
pub const T_CoerceToDomainState: ::libc::c_uint = 425;
pub const T_DomainConstraintState: ::libc::c_uint = 426;
pub const T_PlannerInfo: ::libc::c_uint = 500;
pub const T_PlannerGlobal: ::libc::c_uint = 501;
pub const T_RelOptInfo: ::libc::c_uint = 502;
pub const T_IndexOptInfo: ::libc::c_uint = 503;
pub const T_ParamPathInfo: ::libc::c_uint = 504;
pub const T_Path: ::libc::c_uint = 505;
pub const T_IndexPath: ::libc::c_uint = 506;
pub const T_BitmapHeapPath: ::libc::c_uint = 507;
pub const T_BitmapAndPath: ::libc::c_uint = 508;
pub const T_BitmapOrPath: ::libc::c_uint = 509;
pub const T_NestPath: ::libc::c_uint = 510;
pub const T_MergePath: ::libc::c_uint = 511;
pub const T_HashPath: ::libc::c_uint = 512;
pub const T_TidPath: ::libc::c_uint = 513;
pub const T_ForeignPath: ::libc::c_uint = 514;
pub const T_AppendPath: ::libc::c_uint = 515;
pub const T_MergeAppendPath: ::libc::c_uint = 516;
pub const T_ResultPath: ::libc::c_uint = 517;
pub const T_MaterialPath: ::libc::c_uint = 518;
pub const T_UniquePath: ::libc::c_uint = 519;
pub const T_EquivalenceClass: ::libc::c_uint = 520;
pub const T_EquivalenceMember: ::libc::c_uint = 521;
pub const T_PathKey: ::libc::c_uint = 522;
pub const T_RestrictInfo: ::libc::c_uint = 523;
pub const T_PlaceHolderVar: ::libc::c_uint = 524;
pub const T_SpecialJoinInfo: ::libc::c_uint = 525;
pub const T_LateralJoinInfo: ::libc::c_uint = 526;
pub const T_AppendRelInfo: ::libc::c_uint = 527;
pub const T_PlaceHolderInfo: ::libc::c_uint = 528;
pub const T_MinMaxAggInfo: ::libc::c_uint = 529;
pub const T_PlannerParamItem: ::libc::c_uint = 530;
pub const T_MemoryContext: ::libc::c_uint = 600;
pub const T_AllocSetContext: ::libc::c_uint = 601;
pub const T_Value: ::libc::c_uint = 650;
pub const T_Integer: ::libc::c_uint = 651;
pub const T_Float: ::libc::c_uint = 652;
pub const T_String: ::libc::c_uint = 653;
pub const T_BitString: ::libc::c_uint = 654;
pub const T_Null: ::libc::c_uint = 655;
pub const T_List: ::libc::c_uint = 656;
pub const T_IntList: ::libc::c_uint = 657;
pub const T_OidList: ::libc::c_uint = 658;
pub const T_Query: ::libc::c_uint = 700;
pub const T_PlannedStmt: ::libc::c_uint = 701;
pub const T_InsertStmt: ::libc::c_uint = 702;
pub const T_DeleteStmt: ::libc::c_uint = 703;
pub const T_UpdateStmt: ::libc::c_uint = 704;
pub const T_SelectStmt: ::libc::c_uint = 705;
pub const T_AlterTableStmt: ::libc::c_uint = 706;
pub const T_AlterTableCmd: ::libc::c_uint = 707;
pub const T_AlterDomainStmt: ::libc::c_uint = 708;
pub const T_SetOperationStmt: ::libc::c_uint = 709;
pub const T_GrantStmt: ::libc::c_uint = 710;
pub const T_GrantRoleStmt: ::libc::c_uint = 711;
pub const T_AlterDefaultPrivilegesStmt: ::libc::c_uint = 712;
pub const T_ClosePortalStmt: ::libc::c_uint = 713;
pub const T_ClusterStmt: ::libc::c_uint = 714;
pub const T_CopyStmt: ::libc::c_uint = 715;
pub const T_CreateStmt: ::libc::c_uint = 716;
pub const T_DefineStmt: ::libc::c_uint = 717;
pub const T_DropStmt: ::libc::c_uint = 718;
pub const T_TruncateStmt: ::libc::c_uint = 719;
pub const T_CommentStmt: ::libc::c_uint = 720;
pub const T_FetchStmt: ::libc::c_uint = 721;
pub const T_IndexStmt: ::libc::c_uint = 722;
pub const T_CreateFunctionStmt: ::libc::c_uint = 723;
pub const T_AlterFunctionStmt: ::libc::c_uint = 724;
pub const T_DoStmt: ::libc::c_uint = 725;
pub const T_RenameStmt: ::libc::c_uint = 726;
pub const T_RuleStmt: ::libc::c_uint = 727;
pub const T_NotifyStmt: ::libc::c_uint = 728;
pub const T_ListenStmt: ::libc::c_uint = 729;
pub const T_UnlistenStmt: ::libc::c_uint = 730;
pub const T_TransactionStmt: ::libc::c_uint = 731;
pub const T_ViewStmt: ::libc::c_uint = 732;
pub const T_LoadStmt: ::libc::c_uint = 733;
pub const T_CreateDomainStmt: ::libc::c_uint = 734;
pub const T_CreatedbStmt: ::libc::c_uint = 735;
pub const T_DropdbStmt: ::libc::c_uint = 736;
pub const T_VacuumStmt: ::libc::c_uint = 737;
pub const T_ExplainStmt: ::libc::c_uint = 738;
pub const T_CreateTableAsStmt: ::libc::c_uint = 739;
pub const T_CreateSeqStmt: ::libc::c_uint = 740;
pub const T_AlterSeqStmt: ::libc::c_uint = 741;
pub const T_VariableSetStmt: ::libc::c_uint = 742;
pub const T_VariableShowStmt: ::libc::c_uint = 743;
pub const T_DiscardStmt: ::libc::c_uint = 744;
pub const T_CreateTrigStmt: ::libc::c_uint = 745;
pub const T_CreatePLangStmt: ::libc::c_uint = 746;
pub const T_CreateRoleStmt: ::libc::c_uint = 747;
pub const T_AlterRoleStmt: ::libc::c_uint = 748;
pub const T_DropRoleStmt: ::libc::c_uint = 749;
pub const T_LockStmt: ::libc::c_uint = 750;
pub const T_ConstraintsSetStmt: ::libc::c_uint = 751;
pub const T_ReindexStmt: ::libc::c_uint = 752;
pub const T_CheckPointStmt: ::libc::c_uint = 753;
pub const T_CreateSchemaStmt: ::libc::c_uint = 754;
pub const T_AlterDatabaseStmt: ::libc::c_uint = 755;
pub const T_AlterDatabaseSetStmt: ::libc::c_uint = 756;
pub const T_AlterRoleSetStmt: ::libc::c_uint = 757;
pub const T_CreateConversionStmt: ::libc::c_uint = 758;
pub const T_CreateCastStmt: ::libc::c_uint = 759;
pub const T_CreateOpClassStmt: ::libc::c_uint = 760;
pub const T_CreateOpFamilyStmt: ::libc::c_uint = 761;
pub const T_AlterOpFamilyStmt: ::libc::c_uint = 762;
pub const T_PrepareStmt: ::libc::c_uint = 763;
pub const T_ExecuteStmt: ::libc::c_uint = 764;
pub const T_DeallocateStmt: ::libc::c_uint = 765;
pub const T_DeclareCursorStmt: ::libc::c_uint = 766;
pub const T_CreateTableSpaceStmt: ::libc::c_uint = 767;
pub const T_DropTableSpaceStmt: ::libc::c_uint = 768;
pub const T_AlterObjectSchemaStmt: ::libc::c_uint = 769;
pub const T_AlterOwnerStmt: ::libc::c_uint = 770;
pub const T_DropOwnedStmt: ::libc::c_uint = 771;
pub const T_ReassignOwnedStmt: ::libc::c_uint = 772;
pub const T_CompositeTypeStmt: ::libc::c_uint = 773;
pub const T_CreateEnumStmt: ::libc::c_uint = 774;
pub const T_CreateRangeStmt: ::libc::c_uint = 775;
pub const T_AlterEnumStmt: ::libc::c_uint = 776;
pub const T_AlterTSDictionaryStmt: ::libc::c_uint = 777;
pub const T_AlterTSConfigurationStmt: ::libc::c_uint = 778;
pub const T_CreateFdwStmt: ::libc::c_uint = 779;
pub const T_AlterFdwStmt: ::libc::c_uint = 780;
pub const T_CreateForeignServerStmt: ::libc::c_uint = 781;
pub const T_AlterForeignServerStmt: ::libc::c_uint = 782;
pub const T_CreateUserMappingStmt: ::libc::c_uint = 783;
pub const T_AlterUserMappingStmt: ::libc::c_uint = 784;
pub const T_DropUserMappingStmt: ::libc::c_uint = 785;
pub const T_AlterTableSpaceOptionsStmt: ::libc::c_uint = 786;
pub const T_AlterTableMoveAllStmt: ::libc::c_uint = 787;
pub const T_SecLabelStmt: ::libc::c_uint = 788;
pub const T_CreateForeignTableStmt: ::libc::c_uint = 789;
pub const T_CreateExtensionStmt: ::libc::c_uint = 790;
pub const T_AlterExtensionStmt: ::libc::c_uint = 791;
pub const T_AlterExtensionContentsStmt: ::libc::c_uint = 792;
pub const T_CreateEventTrigStmt: ::libc::c_uint = 793;
pub const T_AlterEventTrigStmt: ::libc::c_uint = 794;
pub const T_RefreshMatViewStmt: ::libc::c_uint = 795;
pub const T_ReplicaIdentityStmt: ::libc::c_uint = 796;
pub const T_AlterSystemStmt: ::libc::c_uint = 797;
pub const T_A_Expr: ::libc::c_uint = 900;
pub const T_ColumnRef: ::libc::c_uint = 901;
pub const T_ParamRef: ::libc::c_uint = 902;
pub const T_A_Const: ::libc::c_uint = 903;
pub const T_FuncCall: ::libc::c_uint = 904;
pub const T_A_Star: ::libc::c_uint = 905;
pub const T_A_Indices: ::libc::c_uint = 906;
pub const T_A_Indirection: ::libc::c_uint = 907;
pub const T_A_ArrayExpr: ::libc::c_uint = 908;
pub const T_ResTarget: ::libc::c_uint = 909;
pub const T_TypeCast: ::libc::c_uint = 910;
pub const T_CollateClause: ::libc::c_uint = 911;
pub const T_SortBy: ::libc::c_uint = 912;
pub const T_WindowDef: ::libc::c_uint = 913;
pub const T_RangeSubselect: ::libc::c_uint = 914;
pub const T_RangeFunction: ::libc::c_uint = 915;
pub const T_TypeName: ::libc::c_uint = 916;
pub const T_ColumnDef: ::libc::c_uint = 917;
pub const T_IndexElem: ::libc::c_uint = 918;
pub const T_Constraint: ::libc::c_uint = 919;
pub const T_DefElem: ::libc::c_uint = 920;
pub const T_RangeTblEntry: ::libc::c_uint = 921;
pub const T_RangeTblFunction: ::libc::c_uint = 922;
pub const T_WithCheckOption: ::libc::c_uint = 923;
pub const T_SortGroupClause: ::libc::c_uint = 924;
pub const T_WindowClause: ::libc::c_uint = 925;
pub const T_PrivGrantee: ::libc::c_uint = 926;
pub const T_FuncWithArgs: ::libc::c_uint = 927;
pub const T_AccessPriv: ::libc::c_uint = 928;
pub const T_CreateOpClassItem: ::libc::c_uint = 929;
pub const T_TableLikeClause: ::libc::c_uint = 930;
pub const T_FunctionParameter: ::libc::c_uint = 931;
pub const T_LockingClause: ::libc::c_uint = 932;
pub const T_RowMarkClause: ::libc::c_uint = 933;
pub const T_XmlSerialize: ::libc::c_uint = 934;
pub const T_WithClause: ::libc::c_uint = 935;
pub const T_CommonTableExpr: ::libc::c_uint = 936;
pub const T_IdentifySystemCmd: ::libc::c_uint = 937;
pub const T_BaseBackupCmd: ::libc::c_uint = 938;
pub const T_CreateReplicationSlotCmd: ::libc::c_uint = 939;
pub const T_DropReplicationSlotCmd: ::libc::c_uint = 940;
pub const T_StartReplicationCmd: ::libc::c_uint = 941;
pub const T_TimeLineHistoryCmd: ::libc::c_uint = 942;
pub const T_TriggerData: ::libc::c_uint = 950;
pub const T_EventTriggerData: ::libc::c_uint = 951;
pub const T_ReturnSetInfo: ::libc::c_uint = 952;
pub const T_WindowObjectData: ::libc::c_uint = 953;
pub const T_TIDBitmap: ::libc::c_uint = 954;
pub const T_InlineCodeBlock: ::libc::c_uint = 955;
pub const T_FdwRoutine: ::libc::c_uint = 956;
pub type NodeTag = Enum_NodeTag;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Node {
    pub _type: NodeTag,
}
impl ::std::clone::Clone for Struct_Node {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Node {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Node = Struct_Node;
pub type Selectivity = ::libc::c_double;
pub type Cost = ::libc::c_double;
pub type Enum_CmdType = ::libc::c_uint;
pub const CMD_UNKNOWN: ::libc::c_uint = 0;
pub const CMD_SELECT: ::libc::c_uint = 1;
pub const CMD_UPDATE: ::libc::c_uint = 2;
pub const CMD_INSERT: ::libc::c_uint = 3;
pub const CMD_DELETE: ::libc::c_uint = 4;
pub const CMD_UTILITY: ::libc::c_uint = 5;
pub const CMD_NOTHING: ::libc::c_uint = 6;
pub type CmdType = Enum_CmdType;
pub type Enum_JoinType = ::libc::c_uint;
pub const JOIN_INNER: ::libc::c_uint = 0;
pub const JOIN_LEFT: ::libc::c_uint = 1;
pub const JOIN_FULL: ::libc::c_uint = 2;
pub const JOIN_RIGHT: ::libc::c_uint = 3;
pub const JOIN_SEMI: ::libc::c_uint = 4;
pub const JOIN_ANTI: ::libc::c_uint = 5;
pub const JOIN_UNIQUE_OUTER: ::libc::c_uint = 6;
pub const JOIN_UNIQUE_INNER: ::libc::c_uint = 7;
pub type JoinType = Enum_JoinType;
pub type ListCell = Struct_ListCell;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_List {
    pub _type: NodeTag,
    pub length: ::libc::c_int,
    pub head: *mut ListCell,
    pub tail: *mut ListCell,
}
impl ::std::clone::Clone for Struct_List {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_List {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type List = Struct_List;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ListCell {
    pub data: Union_Unnamed22,
    pub next: *mut ListCell,
}
impl ::std::clone::Clone for Struct_ListCell {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ListCell {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed22 {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_Unnamed22 {
    pub unsafe fn ptr_value(&mut self) -> *mut *mut ::libc::c_void {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn int_value(&mut self) -> *mut ::libc::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn oid_value(&mut self) -> *mut Oid {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed22 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed22 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_attrDefault {
    pub adnum: AttrNumber,
    pub adbin: *mut ::libc::c_char,
}
impl ::std::clone::Clone for Struct_attrDefault {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_attrDefault {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AttrDefault = Struct_attrDefault;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_constrCheck {
    pub ccname: *mut ::libc::c_char,
    pub ccbin: *mut ::libc::c_char,
    pub ccvalid: _bool,
    pub ccnoinherit: _bool,
}
impl ::std::clone::Clone for Struct_constrCheck {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_constrCheck {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ConstrCheck = Struct_constrCheck;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_tupleConstr {
    pub defval: *mut AttrDefault,
    pub check: *mut ConstrCheck,
    pub num_defval: uint16,
    pub num_check: uint16,
    pub has_not_null: _bool,
}
impl ::std::clone::Clone for Struct_tupleConstr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_tupleConstr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TupleConstr = Struct_tupleConstr;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_tupleDesc {
    pub natts: ::libc::c_int,
    pub attrs: *mut Form_pg_attribute,
    pub constr: *mut TupleConstr,
    pub tdtypeid: Oid,
    pub tdtypmod: int32,
    pub tdhasoid: _bool,
    pub tdrefcount: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_tupleDesc {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_tupleDesc {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TupleDesc = *mut Struct_tupleDesc;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_flock {
    pub l_start: off_t,
    pub l_len: off_t,
    pub l_pid: pid_t,
    pub l_type: ::libc::c_short,
    pub l_whence: ::libc::c_short,
}
impl ::std::clone::Clone for Struct_flock {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_flock {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_timespec {
    pub tv_sec: __darwin_time_t,
    pub tv_nsec: ::libc::c_long,
}
impl ::std::clone::Clone for Struct_timespec {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_timespec {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_flocktimeout {
    pub fl: Struct_flock,
    pub timeout: Struct_timespec,
}
impl ::std::clone::Clone for Struct_flocktimeout {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_flocktimeout {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_radvisory {
    pub ra_offset: off_t,
    pub ra_count: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_radvisory {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_radvisory {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_fsignatures {
    pub fs_file_start: off_t,
    pub fs_blob_start: *mut ::libc::c_void,
    pub fs_blob_size: size_t,
}
impl ::std::clone::Clone for Struct_fsignatures {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_fsignatures {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type fsignatures_t = Struct_fsignatures;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_fstore {
    pub fst_flags: ::libc::c_uint,
    pub fst_posmode: ::libc::c_int,
    pub fst_offset: off_t,
    pub fst_length: off_t,
    pub fst_bytesalloc: off_t,
}
impl ::std::clone::Clone for Struct_fstore {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_fstore {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type fstore_t = Struct_fstore;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_fbootstraptransfer {
    pub fbt_offset: off_t,
    pub fbt_length: size_t,
    pub fbt_buffer: *mut ::libc::c_void,
}
impl ::std::clone::Clone for Struct_fbootstraptransfer {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_fbootstraptransfer {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type fbootstraptransfer_t = Struct_fbootstraptransfer;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_log2phys {
    pub l2p_flags: ::libc::c_uint,
    pub l2p_contigbytes: off_t,
    pub l2p_devoffset: off_t,
}
impl ::std::clone::Clone for Struct_log2phys {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_log2phys {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__filesec { }
pub type filesec_t = *mut Struct__filesec;
pub type Enum_Unnamed23 = ::libc::c_uint;
pub const FILESEC_OWNER: ::libc::c_uint = 1;
pub const FILESEC_GROUP: ::libc::c_uint = 2;
pub const FILESEC_UUID: ::libc::c_uint = 3;
pub const FILESEC_MODE: ::libc::c_uint = 4;
pub const FILESEC_ACL: ::libc::c_uint = 5;
pub const FILESEC_GRPUUID: ::libc::c_uint = 6;
pub const FILESEC_ACL_RAW: ::libc::c_uint = 100;
pub const FILESEC_ACL_ALLOCSIZE: ::libc::c_uint = 101;
pub type filesec_property_t = Enum_Unnamed23;
pub type XLogRecPtr = uint64;
pub type XLogSegNo = uint64;
pub type TimeLineID = uint32;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VariableCacheData {
    pub nextOid: Oid,
    pub oidCount: uint32,
    pub nextXid: TransactionId,
    pub oldestXid: TransactionId,
    pub xidVacLimit: TransactionId,
    pub xidWarnLimit: TransactionId,
    pub xidStopLimit: TransactionId,
    pub xidWrapLimit: TransactionId,
    pub oldestXidDB: Oid,
    pub latestCompletedXid: TransactionId,
}
impl ::std::clone::Clone for Struct_VariableCacheData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VariableCacheData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VariableCacheData = Struct_VariableCacheData;
pub type VariableCache = *mut VariableCacheData;
pub type Item = Pointer;
pub type Page = Pointer;
pub type LocationIndex = uint16;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed24 {
    pub xlogid: uint32,
    pub xrecoff: uint32,
}
impl ::std::clone::Clone for Struct_Unnamed24 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed24 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type PageXLogRecPtr = Struct_Unnamed24;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_PageHeaderData {
    pub pd_lsn: PageXLogRecPtr,
    pub pd_checksum: uint16,
    pub pd_flags: uint16,
    pub pd_lower: LocationIndex,
    pub pd_upper: LocationIndex,
    pub pd_special: LocationIndex,
    pub pd_pagesize_version: uint16,
    pub pd_prune_xid: TransactionId,
    pub pd_linp: [ItemIdData; 1usize],
}
impl ::std::clone::Clone for Struct_PageHeaderData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_PageHeaderData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type PageHeaderData = Struct_PageHeaderData;
pub type PageHeader = *mut PageHeaderData;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_HeapTupleFields {
    pub t_xmin: TransactionId,
    pub t_xmax: TransactionId,
    pub t_field3: Union_Unnamed25,
}
impl ::std::clone::Clone for Struct_HeapTupleFields {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_HeapTupleFields {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed25 {
    pub _bindgen_data_: [u32; 1usize],
}
impl Union_Unnamed25 {
    pub unsafe fn t_cid(&mut self) -> *mut CommandId {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn t_xvac(&mut self) -> *mut TransactionId {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed25 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed25 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HeapTupleFields = Struct_HeapTupleFields;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_DatumTupleFields {
    pub datum_len_: int32,
    pub datum_typmod: int32,
    pub datum_typeid: Oid,
}
impl ::std::clone::Clone for Struct_DatumTupleFields {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_DatumTupleFields {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DatumTupleFields = Struct_DatumTupleFields;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_HeapTupleHeaderData {
    pub t_choice: Union_Unnamed26,
    pub t_ctid: ItemPointerData,
    pub t_infomask2: uint16,
    pub t_infomask: uint16,
    pub t_hoff: uint8,
    pub t_bits: [bits8; 1usize],
}
impl ::std::clone::Clone for Struct_HeapTupleHeaderData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_HeapTupleHeaderData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed26 {
    pub _bindgen_data_: [u32; 3usize],
}
impl Union_Unnamed26 {
    pub unsafe fn t_heap(&mut self) -> *mut HeapTupleFields {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn t_datum(&mut self) -> *mut DatumTupleFields {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed26 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed26 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_MinimalTupleData {
    pub t_len: uint32,
    pub mt_padding: [::libc::c_char; 6usize],
    pub t_infomask2: uint16,
    pub t_infomask: uint16,
    pub t_hoff: uint8,
    pub t_bits: [bits8; 1usize],
}
impl ::std::clone::Clone for Struct_MinimalTupleData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_MinimalTupleData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type dlist_node = Struct_dlist_node;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_dlist_node {
    pub prev: *mut dlist_node,
    pub next: *mut dlist_node,
}
impl ::std::clone::Clone for Struct_dlist_node {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_dlist_node {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_dlist_head {
    pub head: dlist_node,
}
impl ::std::clone::Clone for Struct_dlist_head {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_dlist_head {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type dlist_head = Struct_dlist_head;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_dlist_iter {
    pub cur: *mut dlist_node,
    pub end: *mut dlist_node,
}
impl ::std::clone::Clone for Struct_dlist_iter {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_dlist_iter {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type dlist_iter = Struct_dlist_iter;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_dlist_mutable_iter {
    pub cur: *mut dlist_node,
    pub next: *mut dlist_node,
    pub end: *mut dlist_node,
}
impl ::std::clone::Clone for Struct_dlist_mutable_iter {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_dlist_mutable_iter {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type dlist_mutable_iter = Struct_dlist_mutable_iter;
pub type slist_node = Struct_slist_node;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_slist_node {
    pub next: *mut slist_node,
}
impl ::std::clone::Clone for Struct_slist_node {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_slist_node {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_slist_head {
    pub head: slist_node,
}
impl ::std::clone::Clone for Struct_slist_head {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_slist_head {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type slist_head = Struct_slist_head;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_slist_iter {
    pub cur: *mut slist_node,
}
impl ::std::clone::Clone for Struct_slist_iter {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_slist_iter {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type slist_iter = Struct_slist_iter;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_slist_mutable_iter {
    pub cur: *mut slist_node,
    pub next: *mut slist_node,
    pub prev: *mut slist_node,
}
impl ::std::clone::Clone for Struct_slist_mutable_iter {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_slist_mutable_iter {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type slist_mutable_iter = Struct_slist_mutable_iter;
pub type Enum_ForkNumber = ::libc::c_int;
pub const InvalidForkNumber: ::libc::c_int = -1;
pub const MAIN_FORKNUM: ::libc::c_int = 0;
pub const FSM_FORKNUM: ::libc::c_int = 1;
pub const VISIBILITYMAP_FORKNUM: ::libc::c_int = 2;
pub const INIT_FORKNUM: ::libc::c_int = 3;
pub type ForkNumber = Enum_ForkNumber;
pub type BackendId = ::libc::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RelFileNode {
    pub spcNode: Oid,
    pub dbNode: Oid,
    pub relNode: Oid,
}
impl ::std::clone::Clone for Struct_RelFileNode {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RelFileNode {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RelFileNode = Struct_RelFileNode;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RelFileNodeBackend {
    pub node: RelFileNode,
    pub backend: BackendId,
}
impl ::std::clone::Clone for Struct_RelFileNodeBackend {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RelFileNodeBackend {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RelFileNodeBackend = Struct_RelFileNodeBackend;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed27 {
    pub id: int8,
    pub dbId: Oid,
    pub hashValue: uint32,
}
impl ::std::clone::Clone for Struct_Unnamed27 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed27 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SharedInvalCatcacheMsg = Struct_Unnamed27;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed28 {
    pub id: int8,
    pub dbId: Oid,
    pub catId: Oid,
}
impl ::std::clone::Clone for Struct_Unnamed28 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed28 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SharedInvalCatalogMsg = Struct_Unnamed28;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed29 {
    pub id: int8,
    pub dbId: Oid,
    pub relId: Oid,
}
impl ::std::clone::Clone for Struct_Unnamed29 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed29 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SharedInvalRelcacheMsg = Struct_Unnamed29;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed30 {
    pub id: int8,
    pub backend_hi: int8,
    pub backend_lo: uint16,
    pub rnode: RelFileNode,
}
impl ::std::clone::Clone for Struct_Unnamed30 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed30 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SharedInvalSmgrMsg = Struct_Unnamed30;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed31 {
    pub id: int8,
    pub dbId: Oid,
}
impl ::std::clone::Clone for Struct_Unnamed31 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed31 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SharedInvalRelmapMsg = Struct_Unnamed31;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed32 {
    pub id: int8,
    pub dbId: Oid,
    pub relId: Oid,
}
impl ::std::clone::Clone for Struct_Unnamed32 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed32 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SharedInvalSnapshotMsg = Struct_Unnamed32;
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed33 {
    pub _bindgen_data_: [u32; 4usize],
}
impl Union_Unnamed33 {
    pub unsafe fn id(&mut self) -> *mut int8 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn cc(&mut self) -> *mut SharedInvalCatcacheMsg {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn cat(&mut self) -> *mut SharedInvalCatalogMsg {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn rc(&mut self) -> *mut SharedInvalRelcacheMsg {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn sm(&mut self) -> *mut SharedInvalSmgrMsg {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn rm(&mut self) -> *mut SharedInvalRelmapMsg {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn sn(&mut self) -> *mut SharedInvalSnapshotMsg {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed33 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed33 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SharedInvalidationMessage = Union_Unnamed33;
pub type HashValueFunc =
    ::std::option::Option<extern "C" fn(key: *const ::libc::c_void,
                                        keysize: Size) -> uint32>;
pub type HashCompareFunc =
    ::std::option::Option<extern "C" fn(key1: *const ::libc::c_void,
                                        key2: *const ::libc::c_void,
                                        keysize: Size) -> ::libc::c_int>;
pub type HashCopyFunc =
    ::std::option::Option<extern "C" fn(dest: *mut ::libc::c_void,
                                        src: *const ::libc::c_void,
                                        keysize: Size)
                              -> *mut ::libc::c_void>;
pub type HashAllocFunc =
    ::std::option::Option<extern "C" fn(request: Size)
                              -> *mut ::libc::c_void>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_HASHELEMENT {
    pub link: *mut Struct_HASHELEMENT,
    pub hashvalue: uint32,
}
impl ::std::clone::Clone for Struct_HASHELEMENT {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_HASHELEMENT {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HASHELEMENT = Struct_HASHELEMENT;
pub enum Struct_HASHHDR { }
pub type HASHHDR = Struct_HASHHDR;
pub enum Struct_HTAB { }
pub type HTAB = Struct_HTAB;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_HASHCTL {
    pub num_partitions: ::libc::c_long,
    pub ssize: ::libc::c_long,
    pub dsize: ::libc::c_long,
    pub max_dsize: ::libc::c_long,
    pub ffactor: ::libc::c_long,
    pub keysize: Size,
    pub entrysize: Size,
    pub hash: HashValueFunc,
    pub _match: HashCompareFunc,
    pub keycopy: HashCopyFunc,
    pub alloc: HashAllocFunc,
    pub hcxt: MemoryContext,
    pub hctl: *mut HASHHDR,
}
impl ::std::clone::Clone for Struct_HASHCTL {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_HASHCTL {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HASHCTL = Struct_HASHCTL;
pub type Enum_Unnamed34 = ::libc::c_uint;
pub const HASH_FIND: ::libc::c_uint = 0;
pub const HASH_ENTER: ::libc::c_uint = 1;
pub const HASH_REMOVE: ::libc::c_uint = 2;
pub const HASH_ENTER_NULL: ::libc::c_uint = 3;
pub type HASHACTION = Enum_Unnamed34;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed35 {
    pub hashp: *mut HTAB,
    pub curBucket: uint32,
    pub curEntry: *mut HASHELEMENT,
}
impl ::std::clone::Clone for Struct_Unnamed35 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed35 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HASH_SEQ_STATUS = Struct_Unnamed35;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_FormData_pg_am {
    pub amname: NameData,
    pub amstrategies: int16,
    pub amsupport: int16,
    pub amcanorder: _bool,
    pub amcanorderbyop: _bool,
    pub amcanbackward: _bool,
    pub amcanunique: _bool,
    pub amcanmulticol: _bool,
    pub amoptionalkey: _bool,
    pub amsearcharray: _bool,
    pub amsearchnulls: _bool,
    pub amstorage: _bool,
    pub amclusterable: _bool,
    pub ampredlocks: _bool,
    pub amkeytype: Oid,
    pub aminsert: regproc,
    pub ambeginscan: regproc,
    pub amgettuple: regproc,
    pub amgetbitmap: regproc,
    pub amrescan: regproc,
    pub amendscan: regproc,
    pub ammarkpos: regproc,
    pub amrestrpos: regproc,
    pub ambuild: regproc,
    pub ambuildempty: regproc,
    pub ambulkdelete: regproc,
    pub amvacuumcleanup: regproc,
    pub amcanreturn: regproc,
    pub amcostestimate: regproc,
    pub amoptions: regproc,
}
impl ::std::clone::Clone for Struct_FormData_pg_am {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_FormData_pg_am {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FormData_pg_am = Struct_FormData_pg_am;
pub type Form_pg_am = *mut FormData_pg_am;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_FormData_pg_class {
    pub relname: NameData,
    pub relnamespace: Oid,
    pub reltype: Oid,
    pub reloftype: Oid,
    pub relowner: Oid,
    pub relam: Oid,
    pub relfilenode: Oid,
    pub reltablespace: Oid,
    pub relpages: int32,
    pub reltuples: float4,
    pub relallvisible: int32,
    pub reltoastrelid: Oid,
    pub relhasindex: _bool,
    pub relisshared: _bool,
    pub relpersistence: ::libc::c_char,
    pub relkind: ::libc::c_char,
    pub relnatts: int16,
    pub relchecks: int16,
    pub relhasoids: _bool,
    pub relhaspkey: _bool,
    pub relhasrules: _bool,
    pub relhastriggers: _bool,
    pub relhassubclass: _bool,
    pub relispopulated: _bool,
    pub relreplident: ::libc::c_char,
    pub relfrozenxid: TransactionId,
    pub relminmxid: TransactionId,
}
impl ::std::clone::Clone for Struct_FormData_pg_class {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_FormData_pg_class {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FormData_pg_class = Struct_FormData_pg_class;
pub type Form_pg_class = *mut FormData_pg_class;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_FormData_pg_index {
    pub indexrelid: Oid,
    pub indrelid: Oid,
    pub indnatts: int16,
    pub indisunique: _bool,
    pub indisprimary: _bool,
    pub indisexclusion: _bool,
    pub indimmediate: _bool,
    pub indisclustered: _bool,
    pub indisvalid: _bool,
    pub indcheckxmin: _bool,
    pub indisready: _bool,
    pub indislive: _bool,
    pub indisreplident: _bool,
    pub indkey: int2vector,
}
impl ::std::clone::Clone for Struct_FormData_pg_index {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_FormData_pg_index {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FormData_pg_index = Struct_FormData_pg_index;
pub type Form_pg_index = *mut FormData_pg_index;
pub type fmNodePtr = *mut Struct_Node;
pub enum Struct_Aggref { }
pub type fmAggrefPtr = *mut Struct_Aggref;
pub type fmExprContextCallbackFunction =
    ::std::option::Option<extern "C" fn(arg: Datum) -> ()>;
pub type fmStringInfo = *mut Struct_StringInfoData;
pub type FunctionCallInfo = *mut Struct_FunctionCallInfoData;
pub type PGFunction =
    ::std::option::Option<extern "C" fn(fcinfo: FunctionCallInfo) -> Datum>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_FmgrInfo {
    pub fn_addr: PGFunction,
    pub fn_oid: Oid,
    pub fn_nargs: ::libc::c_short,
    pub fn_strict: _bool,
    pub fn_retset: _bool,
    pub fn_stats: ::libc::c_uchar,
    pub fn_extra: *mut ::libc::c_void,
    pub fn_mcxt: MemoryContext,
    pub fn_expr: fmNodePtr,
}
impl ::std::clone::Clone for Struct_FmgrInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_FmgrInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FmgrInfo = Struct_FmgrInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_FunctionCallInfoData {
    pub flinfo: *mut FmgrInfo,
    pub context: fmNodePtr,
    pub resultinfo: fmNodePtr,
    pub fncollation: Oid,
    pub isnull: _bool,
    pub nargs: ::libc::c_short,
    pub arg: [Datum; 100usize],
    pub argnull: [_bool; 100usize],
}
impl ::std::clone::Clone for Struct_FunctionCallInfoData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_FunctionCallInfoData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FunctionCallInfoData = Struct_FunctionCallInfoData;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed36 {
    pub api_version: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_Unnamed36 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed36 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Pg_finfo_record = Struct_Unnamed36;
pub type PGFInfoFunction =
    ::std::option::Option<extern "C" fn() -> *const Pg_finfo_record>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed37 {
    pub len: ::libc::c_int,
    pub version: ::libc::c_int,
    pub funcmaxargs: ::libc::c_int,
    pub indexmaxkeys: ::libc::c_int,
    pub namedatalen: ::libc::c_int,
    pub float4byval: ::libc::c_int,
    pub float8byval: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_Unnamed37 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed37 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Pg_magic_struct = Struct_Unnamed37;
pub type PGModuleMagicFunction =
    ::std::option::Option<extern "C" fn() -> *const Pg_magic_struct>;
pub type Enum_FmgrHookEventType = ::libc::c_uint;
pub const FHET_START: ::libc::c_uint = 0;
pub const FHET_END: ::libc::c_uint = 1;
pub const FHET_ABORT: ::libc::c_uint = 2;
pub type FmgrHookEventType = Enum_FmgrHookEventType;
pub type needs_fmgr_hook_type =
    ::std::option::Option<extern "C" fn(fn_oid: Oid) -> _bool>;
pub type fmgr_hook_type =
    ::std::option::Option<extern "C" fn(event: FmgrHookEventType,
                                        flinfo: *mut FmgrInfo,
                                        arg: *mut Datum) -> ()>;
pub type bitmapword = uint32;
pub type signedbitmapword = int32;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Bitmapset {
    pub nwords: ::libc::c_int,
    pub words: [bitmapword; 1usize],
}
impl ::std::clone::Clone for Struct_Bitmapset {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Bitmapset {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Bitmapset = Struct_Bitmapset;
pub type Enum_Unnamed38 = ::libc::c_uint;
pub const BMS_EQUAL: ::libc::c_uint = 0;
pub const BMS_SUBSET1: ::libc::c_uint = 1;
pub const BMS_SUBSET2: ::libc::c_uint = 2;
pub const BMS_DIFFERENT: ::libc::c_uint = 3;
pub type BMS_Comparison = Enum_Unnamed38;
pub type Enum_Unnamed39 = ::libc::c_uint;
pub const BMS_EMPTY_SET: ::libc::c_uint = 0;
pub const BMS_SINGLETON: ::libc::c_uint = 1;
pub const BMS_MULTIPLE: ::libc::c_uint = 2;
pub type BMS_Membership = Enum_Unnamed39;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RewriteRule {
    pub ruleId: Oid,
    pub event: CmdType,
    pub qual: *mut Node,
    pub actions: *mut List,
    pub enabled: ::libc::c_char,
    pub isInstead: _bool,
}
impl ::std::clone::Clone for Struct_RewriteRule {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RewriteRule {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RewriteRule = Struct_RewriteRule;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RuleLock {
    pub numLocks: ::libc::c_int,
    pub rules: *mut *mut RewriteRule,
}
impl ::std::clone::Clone for Struct_RuleLock {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RuleLock {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RuleLock = Struct_RuleLock;
pub type Relation = *mut Struct_RelationData;
pub type RelationPtr = *mut Relation;
pub type Enum_IndexAttrBitmapKind = ::libc::c_uint;
pub const INDEX_ATTR_BITMAP_ALL: ::libc::c_uint = 0;
pub const INDEX_ATTR_BITMAP_KEY: ::libc::c_uint = 1;
pub const INDEX_ATTR_BITMAP_IDENTITY_KEY: ::libc::c_uint = 2;
pub type IndexAttrBitmapKind = Enum_IndexAttrBitmapKind;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Trigger {
    pub tgoid: Oid,
    pub tgname: *mut ::libc::c_char,
    pub tgfoid: Oid,
    pub tgtype: int16,
    pub tgenabled: ::libc::c_char,
    pub tgisinternal: _bool,
    pub tgconstrrelid: Oid,
    pub tgconstrindid: Oid,
    pub tgconstraint: Oid,
    pub tgdeferrable: _bool,
    pub tginitdeferred: _bool,
    pub tgnargs: int16,
    pub tgnattr: int16,
    pub tgattr: *mut int16,
    pub tgargs: *mut *mut ::libc::c_char,
    pub tgqual: *mut ::libc::c_char,
}
impl ::std::clone::Clone for Struct_Trigger {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Trigger {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Trigger = Struct_Trigger;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_TriggerDesc {
    pub triggers: *mut Trigger,
    pub numtriggers: ::libc::c_int,
    pub trig_insert_before_row: _bool,
    pub trig_insert_after_row: _bool,
    pub trig_insert_instead_row: _bool,
    pub trig_insert_before_statement: _bool,
    pub trig_insert_after_statement: _bool,
    pub trig_update_before_row: _bool,
    pub trig_update_after_row: _bool,
    pub trig_update_instead_row: _bool,
    pub trig_update_before_statement: _bool,
    pub trig_update_after_statement: _bool,
    pub trig_delete_before_row: _bool,
    pub trig_delete_after_row: _bool,
    pub trig_delete_instead_row: _bool,
    pub trig_delete_before_statement: _bool,
    pub trig_delete_after_statement: _bool,
    pub trig_truncate_before_statement: _bool,
    pub trig_truncate_after_statement: _bool,
}
impl ::std::clone::Clone for Struct_TriggerDesc {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_TriggerDesc {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TriggerDesc = Struct_TriggerDesc;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_LockRelId {
    pub relId: Oid,
    pub dbId: Oid,
}
impl ::std::clone::Clone for Struct_LockRelId {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_LockRelId {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LockRelId = Struct_LockRelId;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_LockInfoData {
    pub lockRelId: LockRelId,
}
impl ::std::clone::Clone for Struct_LockInfoData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_LockInfoData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LockInfoData = Struct_LockInfoData;
pub type LockInfo = *mut LockInfoData;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RelationAmInfo {
    pub aminsert: FmgrInfo,
    pub ambeginscan: FmgrInfo,
    pub amgettuple: FmgrInfo,
    pub amgetbitmap: FmgrInfo,
    pub amrescan: FmgrInfo,
    pub amendscan: FmgrInfo,
    pub ammarkpos: FmgrInfo,
    pub amrestrpos: FmgrInfo,
    pub amcanreturn: FmgrInfo,
}
impl ::std::clone::Clone for Struct_RelationAmInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RelationAmInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RelationAmInfo = Struct_RelationAmInfo;
pub enum Struct_SMgrRelationData { }
pub enum Struct_FdwRoutine { }
pub enum Struct_PgStat_TableStatus { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RelationData {
    pub rd_node: RelFileNode,
    pub rd_smgr: *mut Struct_SMgrRelationData,
    pub rd_refcnt: ::libc::c_int,
    pub rd_backend: BackendId,
    pub rd_islocaltemp: _bool,
    pub rd_isnailed: _bool,
    pub rd_isvalid: _bool,
    pub rd_indexvalid: ::libc::c_char,
    pub rd_createSubid: SubTransactionId,
    pub rd_newRelfilenodeSubid: SubTransactionId,
    pub rd_rel: Form_pg_class,
    pub rd_att: TupleDesc,
    pub rd_id: Oid,
    pub rd_lockInfo: LockInfoData,
    pub rd_rules: *mut RuleLock,
    pub rd_rulescxt: MemoryContext,
    pub trigdesc: *mut TriggerDesc,
    pub rd_indexlist: *mut List,
    pub rd_oidindex: Oid,
    pub rd_replidindex: Oid,
    pub rd_indexattr: *mut Bitmapset,
    pub rd_keyattr: *mut Bitmapset,
    pub rd_idattr: *mut Bitmapset,
    pub rd_options: *mut bytea,
    pub rd_index: Form_pg_index,
    pub rd_indextuple: *mut Struct_HeapTupleData,
    pub rd_am: Form_pg_am,
    pub rd_indexcxt: MemoryContext,
    pub rd_aminfo: *mut RelationAmInfo,
    pub rd_opfamily: *mut Oid,
    pub rd_opcintype: *mut Oid,
    pub rd_support: *mut RegProcedure,
    pub rd_supportinfo: *mut FmgrInfo,
    pub rd_indoption: *mut int16,
    pub rd_indexprs: *mut List,
    pub rd_indpred: *mut List,
    pub rd_exclops: *mut Oid,
    pub rd_exclprocs: *mut Oid,
    pub rd_exclstrats: *mut uint16,
    pub rd_amcache: *mut ::libc::c_void,
    pub rd_indcollation: *mut Oid,
    pub rd_fdwroutine: *mut Struct_FdwRoutine,
    pub rd_toastoid: Oid,
    pub pgstat_info: *mut Struct_PgStat_TableStatus,
}
impl ::std::clone::Clone for Struct_RelationData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RelationData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RelationData = Struct_RelationData;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AutoVacOpts {
    pub enabled: _bool,
    pub vacuum_threshold: ::libc::c_int,
    pub analyze_threshold: ::libc::c_int,
    pub vacuum_cost_delay: ::libc::c_int,
    pub vacuum_cost_limit: ::libc::c_int,
    pub freeze_min_age: ::libc::c_int,
    pub freeze_max_age: ::libc::c_int,
    pub freeze_table_age: ::libc::c_int,
    pub multixact_freeze_min_age: ::libc::c_int,
    pub multixact_freeze_max_age: ::libc::c_int,
    pub multixact_freeze_table_age: ::libc::c_int,
    pub vacuum_scale_factor: float8,
    pub analyze_scale_factor: float8,
}
impl ::std::clone::Clone for Struct_AutoVacOpts {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AutoVacOpts {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AutoVacOpts = Struct_AutoVacOpts;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_StdRdOptions {
    pub vl_len_: int32,
    pub fillfactor: ::libc::c_int,
    pub autovacuum: AutoVacOpts,
    pub user_catalog_table: _bool,
}
impl ::std::clone::Clone for Struct_StdRdOptions {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_StdRdOptions {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type StdRdOptions = Struct_StdRdOptions;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ViewOptions {
    pub vl_len_: int32,
    pub security_barrier: _bool,
    pub check_option_offset: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_ViewOptions {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ViewOptions {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ViewOptions = Struct_ViewOptions;
pub type Buffer = ::libc::c_int;
pub enum Struct_BufferAccessStrategyData { }
pub type BufferAccessStrategy = *mut Struct_BufferAccessStrategyData;
pub type Snapshot = *mut Struct_SnapshotData;
pub type SnapshotSatisfiesFunc =
    ::std::option::Option<extern "C" fn(htup: HeapTuple, snapshot: Snapshot,
                                        buffer: Buffer) -> _bool>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_SnapshotData {
    pub satisfies: SnapshotSatisfiesFunc,
    pub xmin: TransactionId,
    pub xmax: TransactionId,
    pub xip: *mut TransactionId,
    pub xcnt: uint32,
    pub subxcnt: int32,
    pub subxip: *mut TransactionId,
    pub suboverflowed: _bool,
    pub takenDuringRecovery: _bool,
    pub copied: _bool,
    pub curcid: CommandId,
    pub active_count: uint32,
    pub regd_count: uint32,
}
impl ::std::clone::Clone for Struct_SnapshotData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_SnapshotData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SnapshotData = Struct_SnapshotData;
pub type Enum_Unnamed40 = ::libc::c_uint;
pub const HeapTupleMayBeUpdated: ::libc::c_uint = 0;
pub const HeapTupleInvisible: ::libc::c_uint = 1;
pub const HeapTupleSelfUpdated: ::libc::c_uint = 2;
pub const HeapTupleUpdated: ::libc::c_uint = 3;
pub const HeapTupleBeingUpdated: ::libc::c_uint = 4;
pub type HTSU_Result = Enum_Unnamed40;
pub type float_t = ::libc::c_float;
pub type double_t = ::libc::c_double;
#[repr(C)]
#[derive(Copy)]
pub struct Struct___float2 {
    pub __sinval: ::libc::c_float,
    pub __cosval: ::libc::c_float,
}
impl ::std::clone::Clone for Struct___float2 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___float2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___double2 {
    pub __sinval: ::libc::c_double,
    pub __cosval: ::libc::c_double,
}
impl ::std::clone::Clone for Struct___double2 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___double2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_exception {
    pub _type: ::libc::c_int,
    pub name: *mut ::libc::c_char,
    pub arg1: ::libc::c_double,
    pub arg2: ::libc::c_double,
    pub retval: ::libc::c_double,
}
impl ::std::clone::Clone for Struct_exception {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_exception {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Timestamp = int64;
pub type TimestampTz = int64;
pub type TimeOffset = int64;
pub type fsec_t = int32;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed41 {
    pub time: TimeOffset,
    pub day: int32,
    pub month: int32,
}
impl ::std::clone::Clone for Struct_Unnamed41 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed41 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Interval = Struct_Unnamed41;
pub type pg_time_t = int64;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pg_tm {
    pub tm_sec: ::libc::c_int,
    pub tm_min: ::libc::c_int,
    pub tm_hour: ::libc::c_int,
    pub tm_mday: ::libc::c_int,
    pub tm_mon: ::libc::c_int,
    pub tm_year: ::libc::c_int,
    pub tm_wday: ::libc::c_int,
    pub tm_yday: ::libc::c_int,
    pub tm_isdst: ::libc::c_int,
    pub tm_gmtoff: ::libc::c_long,
    pub tm_zone: *const ::libc::c_char,
}
impl ::std::clone::Clone for Struct_pg_tm {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pg_tm {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct_pg_tz { }
pub type pg_tz = Struct_pg_tz;
pub enum Struct_pg_tzenum { }
pub type pg_tzenum = Struct_pg_tzenum;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ReorderBufferTupleBuf {
    pub node: slist_node,
    pub tuple: HeapTupleData,
    pub header: HeapTupleHeaderData,
    pub data: [::libc::c_char; 8160usize],
}
impl ::std::clone::Clone for Struct_ReorderBufferTupleBuf {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ReorderBufferTupleBuf {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ReorderBufferTupleBuf = Struct_ReorderBufferTupleBuf;
pub type Enum_ReorderBufferChangeType = ::libc::c_uint;
pub const REORDER_BUFFER_CHANGE_INSERT: ::libc::c_uint = 0;
pub const REORDER_BUFFER_CHANGE_UPDATE: ::libc::c_uint = 1;
pub const REORDER_BUFFER_CHANGE_DELETE: ::libc::c_uint = 2;
pub const REORDER_BUFFER_CHANGE_INTERNAL_SNAPSHOT: ::libc::c_uint = 3;
pub const REORDER_BUFFER_CHANGE_INTERNAL_COMMAND_ID: ::libc::c_uint = 4;
pub const REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID: ::libc::c_uint = 5;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ReorderBufferChange {
    pub lsn: XLogRecPtr,
    pub action: Enum_ReorderBufferChangeType,
    pub data: Union_Unnamed42,
    pub node: dlist_node,
}
impl ::std::clone::Clone for Struct_ReorderBufferChange {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ReorderBufferChange {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed42 {
    pub _bindgen_data_: [u64; 4usize],
}
impl Union_Unnamed42 {
    pub unsafe fn tp(&mut self) -> *mut Struct_Unnamed43 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn snapshot(&mut self) -> *mut Snapshot {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn command_id(&mut self) -> *mut CommandId {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn tuplecid(&mut self) -> *mut Struct_Unnamed44 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed42 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed42 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed43 {
    pub relnode: RelFileNode,
    pub clear_toast_afterwards: _bool,
    pub oldtuple: *mut ReorderBufferTupleBuf,
    pub newtuple: *mut ReorderBufferTupleBuf,
}
impl ::std::clone::Clone for Struct_Unnamed43 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed43 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed44 {
    pub node: RelFileNode,
    pub tid: ItemPointerData,
    pub cmin: CommandId,
    pub cmax: CommandId,
    pub combocid: CommandId,
}
impl ::std::clone::Clone for Struct_Unnamed44 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed44 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ReorderBufferChange = Struct_ReorderBufferChange;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ReorderBufferTXN {
    pub xid: TransactionId,
    pub has_catalog_changes: _bool,
    pub is_known_as_subxact: _bool,
    pub first_lsn: XLogRecPtr,
    pub final_lsn: XLogRecPtr,
    pub end_lsn: XLogRecPtr,
    pub restart_decoding_lsn: XLogRecPtr,
    pub commit_time: TimestampTz,
    pub base_snapshot: Snapshot,
    pub base_snapshot_lsn: XLogRecPtr,
    pub nentries: uint64,
    pub nentries_mem: uint64,
    pub changes: dlist_head,
    pub tuplecids: dlist_head,
    pub ntuplecids: uint64,
    pub tuplecid_hash: *mut HTAB,
    pub toast_hash: *mut HTAB,
    pub subtxns: dlist_head,
    pub nsubtxns: uint32,
    pub ninvalidations: uint32,
    pub invalidations: *mut SharedInvalidationMessage,
    pub node: dlist_node,
}
impl ::std::clone::Clone for Struct_ReorderBufferTXN {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ReorderBufferTXN {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ReorderBufferTXN = Struct_ReorderBufferTXN;
pub type ReorderBuffer = Struct_ReorderBuffer;
pub type ReorderBufferApplyChangeCB =
    ::std::option::Option<extern "C" fn(rb: *mut ReorderBuffer,
                                        txn: *mut ReorderBufferTXN,
                                        relation: Relation,
                                        change: *mut ReorderBufferChange)
                              -> ()>;
pub type ReorderBufferBeginCB =
    ::std::option::Option<extern "C" fn(rb: *mut ReorderBuffer,
                                        txn: *mut ReorderBufferTXN) -> ()>;
pub type ReorderBufferCommitCB =
    ::std::option::Option<extern "C" fn(rb: *mut ReorderBuffer,
                                        txn: *mut ReorderBufferTXN,
                                        commit_lsn: XLogRecPtr) -> ()>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ReorderBuffer {
    pub by_txn: *mut HTAB,
    pub toplevel_by_lsn: dlist_head,
    pub by_txn_last_xid: TransactionId,
    pub by_txn_last_txn: *mut ReorderBufferTXN,
    pub begin: ReorderBufferBeginCB,
    pub apply_change: ReorderBufferApplyChangeCB,
    pub commit: ReorderBufferCommitCB,
    pub private_data: *mut ::libc::c_void,
    pub context: MemoryContext,
    pub cached_transactions: dlist_head,
    pub nr_cached_transactions: Size,
    pub cached_changes: dlist_head,
    pub nr_cached_changes: Size,
    pub cached_tuplebufs: slist_head,
    pub nr_cached_tuplebufs: Size,
    pub current_restart_decoding_lsn: XLogRecPtr,
    pub outbuf: *mut ::libc::c_char,
    pub outbufsize: Size,
}
impl ::std::clone::Clone for Struct_ReorderBuffer {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ReorderBuffer {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Enum_OutputPluginOutputType = ::libc::c_uint;
pub const OUTPUT_PLUGIN_BINARY_OUTPUT: ::libc::c_uint = 0;
pub const OUTPUT_PLUGIN_TEXTUAL_OUTPUT: ::libc::c_uint = 1;
pub type OutputPluginOutputType = Enum_OutputPluginOutputType;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_OutputPluginOptions {
    pub output_type: OutputPluginOutputType,
}
impl ::std::clone::Clone for Struct_OutputPluginOptions {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_OutputPluginOptions {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type OutputPluginOptions = Struct_OutputPluginOptions;
pub type LogicalOutputPluginInit =
    ::std::option::Option<extern "C" fn(cb: *mut Struct_OutputPluginCallbacks)
                              -> ()>;
pub type LogicalDecodeStartupCB =
    ::std::option::Option<extern "C" fn(ctx:
                                            *mut Struct_LogicalDecodingContext,
                                        options: *mut OutputPluginOptions,
                                        is_init: _bool) -> ()>;
pub type LogicalDecodeBeginCB =
    ::std::option::Option<extern "C" fn(arg1:
                                            *mut Struct_LogicalDecodingContext,
                                        txn: *mut ReorderBufferTXN) -> ()>;
pub type LogicalDecodeChangeCB =
    ::std::option::Option<extern "C" fn(arg1:
                                            *mut Struct_LogicalDecodingContext,
                                        txn: *mut ReorderBufferTXN,
                                        relation: Relation,
                                        change: *mut ReorderBufferChange)
                              -> ()>;
pub type LogicalDecodeCommitCB =
    ::std::option::Option<extern "C" fn(arg1:
                                            *mut Struct_LogicalDecodingContext,
                                        txn: *mut ReorderBufferTXN,
                                        commit_lsn: XLogRecPtr) -> ()>;
pub type LogicalDecodeShutdownCB =
    ::std::option::Option<extern "C" fn(arg1:
                                            *mut Struct_LogicalDecodingContext)
                              -> ()>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_OutputPluginCallbacks {
    pub startup_cb: LogicalDecodeStartupCB,
    pub begin_cb: LogicalDecodeBeginCB,
    pub change_cb: LogicalDecodeChangeCB,
    pub commit_cb: LogicalDecodeCommitCB,
    pub shutdown_cb: LogicalDecodeShutdownCB,
}
impl ::std::clone::Clone for Struct_OutputPluginCallbacks {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_OutputPluginCallbacks {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type OutputPluginCallbacks = Struct_OutputPluginCallbacks;
pub type RmgrId = uint8;
pub type Enum_RmgrIds = ::libc::c_uint;
pub const RM_XLOG_ID: ::libc::c_uint = 0;
pub const RM_XACT_ID: ::libc::c_uint = 1;
pub const RM_SMGR_ID: ::libc::c_uint = 2;
pub const RM_CLOG_ID: ::libc::c_uint = 3;
pub const RM_DBASE_ID: ::libc::c_uint = 4;
pub const RM_TBLSPC_ID: ::libc::c_uint = 5;
pub const RM_MULTIXACT_ID: ::libc::c_uint = 6;
pub const RM_RELMAP_ID: ::libc::c_uint = 7;
pub const RM_STANDBY_ID: ::libc::c_uint = 8;
pub const RM_HEAP2_ID: ::libc::c_uint = 9;
pub const RM_HEAP_ID: ::libc::c_uint = 10;
pub const RM_BTREE_ID: ::libc::c_uint = 11;
pub const RM_HASH_ID: ::libc::c_uint = 12;
pub const RM_GIN_ID: ::libc::c_uint = 13;
pub const RM_GIST_ID: ::libc::c_uint = 14;
pub const RM_SEQ_ID: ::libc::c_uint = 15;
pub const RM_SPGIST_ID: ::libc::c_uint = 16;
pub const RM_NEXT_ID: ::libc::c_uint = 17;
pub type RmgrIds = Enum_RmgrIds;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_StringInfoData {
    pub data: *mut ::libc::c_char,
    pub len: ::libc::c_int,
    pub maxlen: ::libc::c_int,
    pub cursor: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_StringInfoData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_StringInfoData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type StringInfoData = Struct_StringInfoData;
pub type StringInfo = *mut StringInfoData;
pub type pg_crc32 = uint32;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_XLogRecord {
    pub xl_tot_len: uint32,
    pub xl_xid: TransactionId,
    pub xl_len: uint32,
    pub xl_info: uint8,
    pub xl_rmid: RmgrId,
    pub xl_prev: XLogRecPtr,
    pub xl_crc: pg_crc32,
}
impl ::std::clone::Clone for Struct_XLogRecord {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_XLogRecord {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type XLogRecord = Struct_XLogRecord;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_XLogRecData {
    pub data: *mut ::libc::c_char,
    pub len: uint32,
    pub buffer: Buffer,
    pub buffer_std: _bool,
    pub next: *mut Struct_XLogRecData,
}
impl ::std::clone::Clone for Struct_XLogRecData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_XLogRecData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type XLogRecData = Struct_XLogRecData;
pub type Enum_Unnamed45 = ::libc::c_uint;
pub const STANDBY_DISABLED: ::libc::c_uint = 0;
pub const STANDBY_INITIALIZED: ::libc::c_uint = 1;
pub const STANDBY_SNAPSHOT_PENDING: ::libc::c_uint = 2;
pub const STANDBY_SNAPSHOT_READY: ::libc::c_uint = 3;
pub type HotStandbyState = Enum_Unnamed45;
pub type Enum_Unnamed46 = ::libc::c_uint;
pub const RECOVERY_TARGET_UNSET: ::libc::c_uint = 0;
pub const RECOVERY_TARGET_XID: ::libc::c_uint = 1;
pub const RECOVERY_TARGET_TIME: ::libc::c_uint = 2;
pub const RECOVERY_TARGET_NAME: ::libc::c_uint = 3;
pub const RECOVERY_TARGET_IMMEDIATE: ::libc::c_uint = 4;
pub type RecoveryTargetType = Enum_Unnamed46;
pub type Enum_WalLevel = ::libc::c_uint;
pub const WAL_LEVEL_MINIMAL: ::libc::c_uint = 0;
pub const WAL_LEVEL_ARCHIVE: ::libc::c_uint = 1;
pub const WAL_LEVEL_HOT_STANDBY: ::libc::c_uint = 2;
pub const WAL_LEVEL_LOGICAL: ::libc::c_uint = 3;
pub type WalLevel = Enum_WalLevel;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CheckpointStatsData {
    pub ckpt_start_t: TimestampTz,
    pub ckpt_write_t: TimestampTz,
    pub ckpt_sync_t: TimestampTz,
    pub ckpt_sync_end_t: TimestampTz,
    pub ckpt_end_t: TimestampTz,
    pub ckpt_bufs_written: ::libc::c_int,
    pub ckpt_segs_added: ::libc::c_int,
    pub ckpt_segs_removed: ::libc::c_int,
    pub ckpt_segs_recycled: ::libc::c_int,
    pub ckpt_sync_rels: ::libc::c_int,
    pub ckpt_longest_sync: uint64,
    pub ckpt_agg_sync_time: uint64,
}
impl ::std::clone::Clone for Struct_CheckpointStatsData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CheckpointStatsData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CheckpointStatsData = Struct_CheckpointStatsData;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_BkpBlock {
    pub node: RelFileNode,
    pub fork: ForkNumber,
    pub block: BlockNumber,
    pub hole_offset: uint16,
    pub hole_length: uint16,
}
impl ::std::clone::Clone for Struct_BkpBlock {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_BkpBlock {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type BkpBlock = Struct_BkpBlock;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_XLogPageHeaderData {
    pub xlp_magic: uint16,
    pub xlp_info: uint16,
    pub xlp_tli: TimeLineID,
    pub xlp_pageaddr: XLogRecPtr,
    pub xlp_rem_len: uint32,
}
impl ::std::clone::Clone for Struct_XLogPageHeaderData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_XLogPageHeaderData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type XLogPageHeaderData = Struct_XLogPageHeaderData;
pub type XLogPageHeader = *mut XLogPageHeaderData;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_XLogLongPageHeaderData {
    pub std: XLogPageHeaderData,
    pub xlp_sysid: uint64,
    pub xlp_seg_size: uint32,
    pub xlp_xlog_blcksz: uint32,
}
impl ::std::clone::Clone for Struct_XLogLongPageHeaderData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_XLogLongPageHeaderData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type XLogLongPageHeaderData = Struct_XLogLongPageHeaderData;
pub type XLogLongPageHeader = *mut XLogLongPageHeaderData;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_xl_parameter_change {
    pub MaxConnections: ::libc::c_int,
    pub max_worker_processes: ::libc::c_int,
    pub max_prepared_xacts: ::libc::c_int,
    pub max_locks_per_xact: ::libc::c_int,
    pub wal_level: ::libc::c_int,
    pub wal_log_hints: _bool,
}
impl ::std::clone::Clone for Struct_xl_parameter_change {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_xl_parameter_change {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type xl_parameter_change = Struct_xl_parameter_change;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_xl_restore_point {
    pub rp_time: TimestampTz,
    pub rp_name: [::libc::c_char; 64usize],
}
impl ::std::clone::Clone for Struct_xl_restore_point {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_xl_restore_point {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type xl_restore_point = Struct_xl_restore_point;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_xl_end_of_recovery {
    pub end_time: TimestampTz,
    pub ThisTimeLineID: TimeLineID,
    pub PrevTimeLineID: TimeLineID,
}
impl ::std::clone::Clone for Struct_xl_end_of_recovery {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_xl_end_of_recovery {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type xl_end_of_recovery = Struct_xl_end_of_recovery;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RmgrData {
    pub rm_name: *const ::libc::c_char,
    pub rm_redo: ::std::option::Option<extern "C" fn(lsn: XLogRecPtr,
                                                     rptr:
                                                         *mut Struct_XLogRecord)
                                           -> ()>,
    pub rm_desc: ::std::option::Option<extern "C" fn(buf: StringInfo,
                                                     xl_info: uint8,
                                                     rec: *mut ::libc::c_char)
                                           -> ()>,
    pub rm_startup: ::std::option::Option<extern "C" fn() -> ()>,
    pub rm_cleanup: ::std::option::Option<extern "C" fn() -> ()>,
}
impl ::std::clone::Clone for Struct_RmgrData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RmgrData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RmgrData = Struct_RmgrData;
pub type XLogReaderState = Struct_XLogReaderState;
pub type XLogPageReadCB =
    ::std::option::Option<extern "C" fn(xlogreader: *mut XLogReaderState,
                                        targetPagePtr: XLogRecPtr,
                                        reqLen: ::libc::c_int,
                                        targetRecPtr: XLogRecPtr,
                                        readBuf: *mut ::libc::c_char,
                                        pageTLI: *mut TimeLineID)
                              -> ::libc::c_int>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_XLogReaderState {
    pub read_page: XLogPageReadCB,
    pub system_identifier: uint64,
    pub private_data: *mut ::libc::c_void,
    pub ReadRecPtr: XLogRecPtr,
    pub EndRecPtr: XLogRecPtr,
    pub readBuf: *mut ::libc::c_char,
    pub readSegNo: XLogSegNo,
    pub readOff: uint32,
    pub readLen: uint32,
    pub readPageTLI: TimeLineID,
    pub latestPagePtr: XLogRecPtr,
    pub latestPageTLI: TimeLineID,
    pub currRecPtr: XLogRecPtr,
    pub readRecordBuf: *mut ::libc::c_char,
    pub readRecordBufSize: uint32,
    pub errormsg_buf: *mut ::libc::c_char,
}
impl ::std::clone::Clone for Struct_XLogReaderState {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_XLogReaderState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type slock_t = ::libc::c_uchar;
pub enum Struct_PGPROC { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct_LWLockTranche {
    pub name: *const ::libc::c_char,
    pub array_base: *mut ::libc::c_void,
    pub array_stride: Size,
}
impl ::std::clone::Clone for Struct_LWLockTranche {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_LWLockTranche {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LWLockTranche = Struct_LWLockTranche;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_LWLock {
    pub mutex: slock_t,
    pub releaseOK: _bool,
    pub exclusive: ::libc::c_char,
    pub shared: ::libc::c_int,
    pub tranche: ::libc::c_int,
    pub head: *mut Struct_PGPROC,
    pub tail: *mut Struct_PGPROC,
}
impl ::std::clone::Clone for Struct_LWLock {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_LWLock {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LWLock = Struct_LWLock;
#[repr(C)]
#[derive(Copy)]
pub struct Union_LWLockPadded {
    pub _bindgen_data_: [u64; 4usize],
}
impl Union_LWLockPadded {
    pub unsafe fn lock(&mut self) -> *mut LWLock {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn pad(&mut self) -> *mut [::libc::c_char; 32usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_LWLockPadded {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_LWLockPadded {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LWLockPadded = Union_LWLockPadded;
pub type Enum_LWLockMode = ::libc::c_uint;
pub const LW_EXCLUSIVE: ::libc::c_uint = 0;
pub const LW_SHARED: ::libc::c_uint = 1;
pub const LW_WAIT_UNTIL_FREE: ::libc::c_uint = 2;
pub type LWLockMode = Enum_LWLockMode;
pub type LWLockId = *mut LWLock;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_SHM_QUEUE {
    pub prev: *mut Struct_SHM_QUEUE,
    pub next: *mut Struct_SHM_QUEUE,
}
impl ::std::clone::Clone for Struct_SHM_QUEUE {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_SHM_QUEUE {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SHM_QUEUE = Struct_SHM_QUEUE;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed47 {
    pub key: [::libc::c_char; 48usize],
    pub location: *mut ::libc::c_void,
    pub size: Size,
}
impl ::std::clone::Clone for Struct_Unnamed47 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed47 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ShmemIndexEnt = Struct_Unnamed47;
pub type Enum_ReplicationSlotPersistency = ::libc::c_uint;
pub const RS_PERSISTENT: ::libc::c_uint = 0;
pub const RS_EPHEMERAL: ::libc::c_uint = 1;
pub type ReplicationSlotPersistency = Enum_ReplicationSlotPersistency;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ReplicationSlotPersistentData {
    pub name: NameData,
    pub database: Oid,
    pub persistency: ReplicationSlotPersistency,
    pub xmin: TransactionId,
    pub catalog_xmin: TransactionId,
    pub restart_lsn: XLogRecPtr,
    pub confirmed_flush: XLogRecPtr,
    pub plugin: NameData,
}
impl ::std::clone::Clone for Struct_ReplicationSlotPersistentData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ReplicationSlotPersistentData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ReplicationSlotPersistentData = Struct_ReplicationSlotPersistentData;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ReplicationSlot {
    pub mutex: slock_t,
    pub in_use: _bool,
    pub active: _bool,
    pub just_dirtied: _bool,
    pub dirty: _bool,
    pub effective_xmin: TransactionId,
    pub effective_catalog_xmin: TransactionId,
    pub data: ReplicationSlotPersistentData,
    pub io_in_progress_lock: *mut LWLock,
    pub candidate_catalog_xmin: TransactionId,
    pub candidate_xmin_lsn: XLogRecPtr,
    pub candidate_restart_valid: XLogRecPtr,
    pub candidate_restart_lsn: XLogRecPtr,
}
impl ::std::clone::Clone for Struct_ReplicationSlot {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ReplicationSlot {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ReplicationSlot = Struct_ReplicationSlot;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ReplicationSlotCtlData {
    pub replication_slots: [ReplicationSlot; 1usize],
}
impl ::std::clone::Clone for Struct_ReplicationSlotCtlData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ReplicationSlotCtlData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ReplicationSlotCtlData = Struct_ReplicationSlotCtlData;
pub type LogicalOutputPluginWriterWrite =
    ::std::option::Option<extern "C" fn(lr:
                                            *mut Struct_LogicalDecodingContext,
                                        Ptr: XLogRecPtr, xid: TransactionId,
                                        last_write: _bool) -> ()>;
pub type LogicalOutputPluginWriterPrepareWrite =
    LogicalOutputPluginWriterWrite;
pub enum Struct_SnapBuild { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct_LogicalDecodingContext {
    pub context: MemoryContext,
    pub reader: *mut XLogReaderState,
    pub slot: *mut ReplicationSlot,
    pub reorder: *mut Struct_ReorderBuffer,
    pub snapshot_builder: *mut Struct_SnapBuild,
    pub callbacks: OutputPluginCallbacks,
    pub options: OutputPluginOptions,
    pub output_plugin_options: *mut List,
    pub prepare_write: LogicalOutputPluginWriterPrepareWrite,
    pub write: LogicalOutputPluginWriterWrite,
    pub out: StringInfo,
    pub output_plugin_private: *mut ::libc::c_void,
    pub output_writer_private: *mut ::libc::c_void,
    pub accept_writes: _bool,
    pub prepared_write: _bool,
    pub write_location: XLogRecPtr,
    pub write_xid: TransactionId,
}
impl ::std::clone::Clone for Struct_LogicalDecodingContext {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_LogicalDecodingContext {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LogicalDecodingContext = Struct_LogicalDecodingContext;
pub type __va_list_tag = Struct___va_list_tag;
#[repr(C)]
#[derive(Copy)]
pub struct Struct___va_list_tag {
    pub gp_offset: ::libc::c_uint,
    pub fp_offset: ::libc::c_uint,
    pub overflow_arg_area: *mut ::libc::c_void,
    pub reg_save_area: *mut ::libc::c_void,
}
impl ::std::clone::Clone for Struct___va_list_tag {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___va_list_tag {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub static mut __stdinp: *mut FILE;
    pub static mut __stdoutp: *mut FILE;
    pub static mut __stderrp: *mut FILE;
    pub static sys_nerr: ::libc::c_int;
    pub static mut sys_errlist: *const *const ::libc::c_char;
    pub static mut __mb_cur_max: ::libc::c_int;
    pub static mut suboptarg: *mut ::libc::c_char;
    pub static mut _DefaultRuneLocale: _RuneLocale;
    pub static mut _CurrentRuneLocale: *mut _RuneLocale;
    pub static in6addr_any: Struct_in6_addr;
    pub static in6addr_loopback: Struct_in6_addr;
    pub static in6addr_nodelocal_allnodes: Struct_in6_addr;
    pub static in6addr_linklocal_allnodes: Struct_in6_addr;
    pub static in6addr_linklocal_allrouters: Struct_in6_addr;
    pub static in6addr_linklocal_allv2routers: Struct_in6_addr;
    pub static mut h_errno: ::libc::c_int;
    pub static mut error_context_stack: *mut ErrorContextCallback;
    pub static mut PG_exception_stack: *mut sigjmp_buf;
    pub static mut emit_log_hook: emit_log_hook_type;
    pub static mut Log_error_verbosity: ::libc::c_int;
    pub static mut Log_line_prefix: *mut ::libc::c_char;
    pub static mut Log_destination: ::libc::c_int;
    pub static mut Log_destination_string: *mut ::libc::c_char;
    pub static mut CurrentMemoryContext: MemoryContext;
    pub static mut assert_enabled: _bool;
    pub static mut ShmemVariableCache: VariableCache;
    pub static mut forkNames: *const *const ::libc::c_char;
    pub static mut MyBackendId: BackendId;
    pub static mut SharedInvalidMessageCounter: uint64;
    pub static mut no_such_variable: ::libc::c_int;
    pub static mut Dynamic_library_path: *mut ::libc::c_char;
    pub static mut needs_fmgr_hook: needs_fmgr_hook_type;
    pub static mut fmgr_hook: fmgr_hook_type;
    pub static mut criticalRelcachesBuilt: _bool;
    pub static mut criticalSharedRelcachesBuilt: _bool;
    pub static mut signgam: ::libc::c_int;
    pub static mut session_timezone: *mut pg_tz;
    pub static mut log_timezone: *mut pg_tz;
    pub static mut PgStartTime: TimestampTz;
    pub static mut PgReloadTime: TimestampTz;
    pub static mut pg_crc32_table: *const uint32;
    pub static mut sync_method: ::libc::c_int;
    pub static mut ThisTimeLineID: TimeLineID;
    pub static mut InRecovery: _bool;
    pub static mut standbyState: HotStandbyState;
    pub static mut XactLastRecEnd: XLogRecPtr;
    pub static mut reachedConsistency: _bool;
    pub static mut CheckPointSegments: ::libc::c_int;
    pub static mut wal_keep_segments: ::libc::c_int;
    pub static mut XLOGbuffers: ::libc::c_int;
    pub static mut XLogArchiveTimeout: ::libc::c_int;
    pub static mut XLogArchiveMode: _bool;
    pub static mut XLogArchiveCommand: *mut ::libc::c_char;
    pub static mut EnableHotStandby: _bool;
    pub static mut fullPageWrites: _bool;
    pub static mut wal_log_hints: _bool;
    pub static mut log_checkpoints: _bool;
    pub static mut wal_level: ::libc::c_int;
    pub static mut CheckpointStats: CheckpointStatsData;
    pub static mut RmgrTable: *const RmgrData;
    pub static mut ArchiveRecoveryRequested: _bool;
    pub static mut InArchiveRecovery: _bool;
    pub static mut StandbyMode: _bool;
    pub static mut recoveryRestoreCommand: *mut ::libc::c_char;
    pub static mut MainLWLockArray: *mut LWLockPadded;
    pub static mut ReplicationSlotCtl: *mut ReplicationSlotCtlData;
    pub static mut MyReplicationSlot: *mut ReplicationSlot;
    pub static mut max_replication_slots: ::libc::c_int;
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE) -> ();
    pub fn fclose(arg1: *mut FILE) -> ::libc::c_int;
    pub fn feof(arg1: *mut FILE) -> ::libc::c_int;
    pub fn ferror(arg1: *mut FILE) -> ::libc::c_int;
    pub fn fflush(arg1: *mut FILE) -> ::libc::c_int;
    pub fn fgetc(arg1: *mut FILE) -> ::libc::c_int;
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::libc::c_int;
    pub fn fgets(arg1: *mut ::libc::c_char, arg2: ::libc::c_int,
                 arg3: *mut FILE) -> *mut ::libc::c_char;
    pub fn fopen(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char)
     -> *mut FILE;
    pub fn fprintf(arg1: *mut FILE, arg2: *const ::libc::c_char, ...)
     -> ::libc::c_int;
    pub fn fputc(arg1: ::libc::c_int, arg2: *mut FILE) -> ::libc::c_int;
    pub fn fputs(arg1: *const ::libc::c_char, arg2: *mut FILE)
     -> ::libc::c_int;
    pub fn fread(arg1: *mut ::libc::c_void, arg2: size_t, arg3: size_t,
                 arg4: *mut FILE) -> size_t;
    pub fn freopen(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char,
                   arg3: *mut FILE) -> *mut FILE;
    pub fn fscanf(arg1: *mut FILE, arg2: *const ::libc::c_char, ...)
     -> ::libc::c_int;
    pub fn fseek(arg1: *mut FILE, arg2: ::libc::c_long, arg3: ::libc::c_int)
     -> ::libc::c_int;
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::libc::c_int;
    pub fn ftell(arg1: *mut FILE) -> ::libc::c_long;
    pub fn fwrite(arg1: *const ::libc::c_void, arg2: size_t, arg3: size_t,
                  arg4: *mut FILE) -> size_t;
    pub fn getc(arg1: *mut FILE) -> ::libc::c_int;
    pub fn getchar() -> ::libc::c_int;
    pub fn gets(arg1: *mut ::libc::c_char) -> *mut ::libc::c_char;
    pub fn perror(arg1: *const ::libc::c_char) -> ();
    pub fn printf(arg1: *const ::libc::c_char, ...) -> ::libc::c_int;
    pub fn putc(arg1: ::libc::c_int, arg2: *mut FILE) -> ::libc::c_int;
    pub fn putchar(arg1: ::libc::c_int) -> ::libc::c_int;
    pub fn puts(arg1: *const ::libc::c_char) -> ::libc::c_int;
    pub fn remove(arg1: *const ::libc::c_char) -> ::libc::c_int;
    pub fn rename(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char)
     -> ::libc::c_int;
    pub fn rewind(arg1: *mut FILE) -> ();
    pub fn scanf(arg1: *const ::libc::c_char, ...) -> ::libc::c_int;
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::libc::c_char) -> ();
    pub fn setvbuf(arg1: *mut FILE, arg2: *mut ::libc::c_char,
                   arg3: ::libc::c_int, arg4: size_t) -> ::libc::c_int;
    pub fn sprintf(arg1: *mut ::libc::c_char,
                   arg2: *const ::libc::c_char, ...) -> ::libc::c_int;
    pub fn sscanf(arg1: *const ::libc::c_char,
                  arg2: *const ::libc::c_char, ...) -> ::libc::c_int;
    pub fn tmpfile() -> *mut FILE;
    pub fn tmpnam(arg1: *mut ::libc::c_char) -> *mut ::libc::c_char;
    pub fn ungetc(arg1: ::libc::c_int, arg2: *mut FILE) -> ::libc::c_int;
    pub fn vfprintf(arg1: *mut FILE, arg2: *const ::libc::c_char,
                    arg3: va_list) -> ::libc::c_int;
    pub fn vprintf(arg1: *const ::libc::c_char, arg2: va_list)
     -> ::libc::c_int;
    pub fn vsprintf(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char,
                    arg3: va_list) -> ::libc::c_int;
    pub fn ctermid(arg1: *mut ::libc::c_char) -> *mut ::libc::c_char;
    pub fn fdopen(arg1: ::libc::c_int, arg2: *const ::libc::c_char)
     -> *mut FILE;
    pub fn fileno(arg1: *mut FILE) -> ::libc::c_int;
    pub fn pclose(arg1: *mut FILE) -> ::libc::c_int;
    pub fn popen(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char)
     -> *mut FILE;
    pub fn __srget(arg1: *mut FILE) -> ::libc::c_int;
    pub fn __svfscanf(arg1: *mut FILE, arg2: *const ::libc::c_char,
                      arg3: va_list) -> ::libc::c_int;
    pub fn __swbuf(arg1: ::libc::c_int, arg2: *mut FILE) -> ::libc::c_int;
    pub fn __sputc(_c: ::libc::c_int, _p: *mut FILE) -> ::libc::c_int;
    pub fn flockfile(arg1: *mut FILE) -> ();
    pub fn ftrylockfile(arg1: *mut FILE) -> ::libc::c_int;
    pub fn funlockfile(arg1: *mut FILE) -> ();
    pub fn getc_unlocked(arg1: *mut FILE) -> ::libc::c_int;
    pub fn getchar_unlocked() -> ::libc::c_int;
    pub fn putc_unlocked(arg1: ::libc::c_int, arg2: *mut FILE)
     -> ::libc::c_int;
    pub fn putchar_unlocked(arg1: ::libc::c_int) -> ::libc::c_int;
    pub fn getw(arg1: *mut FILE) -> ::libc::c_int;
    pub fn putw(arg1: ::libc::c_int, arg2: *mut FILE) -> ::libc::c_int;
    pub fn tempnam(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char)
     -> *mut ::libc::c_char;
    pub fn fseeko(arg1: *mut FILE, arg2: off_t, arg3: ::libc::c_int)
     -> ::libc::c_int;
    pub fn ftello(arg1: *mut FILE) -> off_t;
    pub fn snprintf(arg1: *mut ::libc::c_char, arg2: size_t,
                    arg3: *const ::libc::c_char, ...) -> ::libc::c_int;
    pub fn vfscanf(arg1: *mut FILE, arg2: *const ::libc::c_char,
                   arg3: va_list) -> ::libc::c_int;
    pub fn vscanf(arg1: *const ::libc::c_char, arg2: va_list)
     -> ::libc::c_int;
    pub fn vsnprintf(arg1: *mut ::libc::c_char, arg2: size_t,
                     arg3: *const ::libc::c_char, arg4: va_list)
     -> ::libc::c_int;
    pub fn vsscanf(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char,
                   arg3: va_list) -> ::libc::c_int;
    pub fn dprintf(arg1: ::libc::c_int, arg2: *const ::libc::c_char, ...)
     -> ::libc::c_int;
    pub fn vdprintf(arg1: ::libc::c_int, arg2: *const ::libc::c_char,
                    arg3: va_list) -> ::libc::c_int;
    pub fn getdelim(arg1: *mut *mut ::libc::c_char, arg2: *mut size_t,
                    arg3: ::libc::c_int, arg4: *mut FILE) -> ssize_t;
    pub fn getline(arg1: *mut *mut ::libc::c_char, arg2: *mut size_t,
                   arg3: *mut FILE) -> ssize_t;
    pub fn asprintf(arg1: *mut *mut ::libc::c_char,
                    arg2: *const ::libc::c_char, ...) -> ::libc::c_int;
    pub fn ctermid_r(arg1: *mut ::libc::c_char) -> *mut ::libc::c_char;
    pub fn fgetln(arg1: *mut FILE, arg2: *mut size_t) -> *mut ::libc::c_char;
    pub fn fmtcheck(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char)
     -> *const ::libc::c_char;
    pub fn fpurge(arg1: *mut FILE) -> ::libc::c_int;
    pub fn setbuffer(arg1: *mut FILE, arg2: *mut ::libc::c_char,
                     arg3: ::libc::c_int) -> ();
    pub fn setlinebuf(arg1: *mut FILE) -> ::libc::c_int;
    pub fn vasprintf(arg1: *mut *mut ::libc::c_char,
                     arg2: *const ::libc::c_char, arg3: va_list)
     -> ::libc::c_int;
    pub fn zopen(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char,
                 arg3: ::libc::c_int) -> *mut FILE;
    pub fn funopen(arg1: *const ::libc::c_void,
                   arg2:
                       ::std::option::Option<extern "C" fn(arg1:
                                                               *mut ::libc::c_void,
                                                           arg2:
                                                               *mut ::libc::c_char,
                                                           arg3:
                                                               ::libc::c_int)
                                                 -> ::libc::c_int>,
                   arg3:
                       ::std::option::Option<extern "C" fn(arg1:
                                                               *mut ::libc::c_void,
                                                           arg2:
                                                               *const ::libc::c_char,
                                                           arg3:
                                                               ::libc::c_int)
                                                 -> ::libc::c_int>,
                   arg4:
                       ::std::option::Option<extern "C" fn(arg1:
                                                               *mut ::libc::c_void,
                                                           arg2: fpos_t,
                                                           arg3:
                                                               ::libc::c_int)
                                                 -> fpos_t>,
                   arg5:
                       ::std::option::Option<extern "C" fn(arg1:
                                                               *mut ::libc::c_void)
                                                 -> ::libc::c_int>)
     -> *mut FILE;
    pub fn __sprintf_chk(arg1: *mut ::libc::c_char, arg2: ::libc::c_int,
                         arg3: size_t, arg4: *const ::libc::c_char, ...)
     -> ::libc::c_int;
    pub fn __snprintf_chk(arg1: *mut ::libc::c_char, arg2: size_t,
                          arg3: ::libc::c_int, arg4: size_t,
                          arg5: *const ::libc::c_char, ...) -> ::libc::c_int;
    pub fn __vsprintf_chk(arg1: *mut ::libc::c_char, arg2: ::libc::c_int,
                          arg3: size_t, arg4: *const ::libc::c_char,
                          arg5: va_list) -> ::libc::c_int;
    pub fn __vsnprintf_chk(arg1: *mut ::libc::c_char, arg2: size_t,
                           arg3: ::libc::c_int, arg4: size_t,
                           arg5: *const ::libc::c_char, arg6: va_list)
     -> ::libc::c_int;
    pub fn signal(arg1: ::libc::c_int,
                  arg2:
                      ::std::option::Option<extern "C" fn(arg1: ::libc::c_int)
                                                -> ()>)
     ->
         ::std::option::Option<extern "C" fn(arg1: ::libc::c_int,
                                             arg2:
                                                 ::std::option::Option<extern "C" fn(arg1:
                                                                                         ::libc::c_int)
                                                                           ->
                                                                               ()>)
                                   -> ()>;
    pub fn getpriority(arg1: ::libc::c_int, arg2: id_t) -> ::libc::c_int;
    pub fn getiopolicy_np(arg1: ::libc::c_int, arg2: ::libc::c_int)
     -> ::libc::c_int;
    pub fn getrlimit(arg1: ::libc::c_int, arg2: *mut Struct_rlimit)
     -> ::libc::c_int;
    pub fn getrusage(arg1: ::libc::c_int, arg2: *mut Struct_rusage)
     -> ::libc::c_int;
    pub fn setpriority(arg1: ::libc::c_int, arg2: id_t, arg3: ::libc::c_int)
     -> ::libc::c_int;
    pub fn setiopolicy_np(arg1: ::libc::c_int, arg2: ::libc::c_int,
                          arg3: ::libc::c_int) -> ::libc::c_int;
    pub fn setrlimit(arg1: ::libc::c_int, arg2: *const Struct_rlimit)
     -> ::libc::c_int;
    pub fn wait(arg1: *mut ::libc::c_int) -> pid_t;
    pub fn waitpid(arg1: pid_t, arg2: *mut ::libc::c_int, arg3: ::libc::c_int)
     -> pid_t;
    pub fn waitid(arg1: idtype_t, arg2: id_t, arg3: *mut siginfo_t,
                  arg4: ::libc::c_int) -> ::libc::c_int;
    pub fn wait3(arg1: *mut ::libc::c_int, arg2: ::libc::c_int,
                 arg3: *mut Struct_rusage) -> pid_t;
    pub fn wait4(arg1: pid_t, arg2: *mut ::libc::c_int, arg3: ::libc::c_int,
                 arg4: *mut Struct_rusage) -> pid_t;
    pub fn alloca(arg1: size_t) -> *mut ::libc::c_void;
    pub fn abort() -> ();
    pub fn abs(arg1: ::libc::c_int) -> ::libc::c_int;
    pub fn atexit(arg1: ::std::option::Option<extern "C" fn() -> ()>)
     -> ::libc::c_int;
    pub fn atof(arg1: *const ::libc::c_char) -> ::libc::c_double;
    pub fn atoi(arg1: *const ::libc::c_char) -> ::libc::c_int;
    pub fn atol(arg1: *const ::libc::c_char) -> ::libc::c_long;
    pub fn atoll(arg1: *const ::libc::c_char) -> ::libc::c_longlong;
    pub fn bsearch(arg1: *const ::libc::c_void, arg2: *const ::libc::c_void,
                   arg3: size_t, arg4: size_t,
                   arg5:
                       ::std::option::Option<extern "C" fn(arg1:
                                                               *const ::libc::c_void,
                                                           arg2:
                                                               *const ::libc::c_void)
                                                 -> ::libc::c_int>)
     -> *mut ::libc::c_void;
    pub fn calloc(arg1: size_t, arg2: size_t) -> *mut ::libc::c_void;
    pub fn div(arg1: ::libc::c_int, arg2: ::libc::c_int) -> div_t;
    pub fn exit(arg1: ::libc::c_int) -> ();
    pub fn free(arg1: *mut ::libc::c_void) -> ();
    pub fn getenv(arg1: *const ::libc::c_char) -> *mut ::libc::c_char;
    pub fn labs(arg1: ::libc::c_long) -> ::libc::c_long;
    pub fn ldiv(arg1: ::libc::c_long, arg2: ::libc::c_long) -> ldiv_t;
    pub fn llabs(arg1: ::libc::c_longlong) -> ::libc::c_longlong;
    pub fn lldiv(arg1: ::libc::c_longlong, arg2: ::libc::c_longlong)
     -> lldiv_t;
    pub fn malloc(arg1: size_t) -> *mut ::libc::c_void;
    pub fn mblen(arg1: *const ::libc::c_char, arg2: size_t) -> ::libc::c_int;
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const ::libc::c_char,
                    arg3: size_t) -> size_t;
    pub fn mbtowc(arg1: *mut wchar_t, arg2: *const ::libc::c_char,
                  arg3: size_t) -> ::libc::c_int;
    pub fn posix_memalign(arg1: *mut *mut ::libc::c_void, arg2: size_t,
                          arg3: size_t) -> ::libc::c_int;
    pub fn qsort(arg1: *mut ::libc::c_void, arg2: size_t, arg3: size_t,
                 arg4:
                     ::std::option::Option<extern "C" fn(arg1:
                                                             *const ::libc::c_void,
                                                         arg2:
                                                             *const ::libc::c_void)
                                               -> ::libc::c_int>) -> ();
    pub fn rand() -> ::libc::c_int;
    pub fn realloc(arg1: *mut ::libc::c_void, arg2: size_t)
     -> *mut ::libc::c_void;
    pub fn srand(arg1: ::libc::c_uint) -> ();
    pub fn strtod(arg1: *const ::libc::c_char, arg2: *mut *mut ::libc::c_char)
     -> ::libc::c_double;
    pub fn strtof(arg1: *const ::libc::c_char, arg2: *mut *mut ::libc::c_char)
     -> ::libc::c_float;
    pub fn strtol(arg1: *const ::libc::c_char, arg2: *mut *mut ::libc::c_char,
                  arg3: ::libc::c_int) -> ::libc::c_long;
    pub fn strtold(arg1: *const ::libc::c_char,
                   arg2: *mut *mut ::libc::c_char) -> ::libc::c_double;
    pub fn strtoll(arg1: *const ::libc::c_char,
                   arg2: *mut *mut ::libc::c_char, arg3: ::libc::c_int)
     -> ::libc::c_longlong;
    pub fn strtoul(arg1: *const ::libc::c_char,
                   arg2: *mut *mut ::libc::c_char, arg3: ::libc::c_int)
     -> ::libc::c_ulong;
    pub fn strtoull(arg1: *const ::libc::c_char,
                    arg2: *mut *mut ::libc::c_char, arg3: ::libc::c_int)
     -> ::libc::c_ulonglong;
    pub fn system(arg1: *const ::libc::c_char) -> ::libc::c_int;
    pub fn wcstombs(arg1: *mut ::libc::c_char, arg2: *const wchar_t,
                    arg3: size_t) -> size_t;
    pub fn wctomb(arg1: *mut ::libc::c_char, arg2: wchar_t) -> ::libc::c_int;
    pub fn _Exit(arg1: ::libc::c_int) -> ();
    pub fn a64l(arg1: *const ::libc::c_char) -> ::libc::c_long;
    pub fn drand48() -> ::libc::c_double;
    pub fn ecvt(arg1: ::libc::c_double, arg2: ::libc::c_int,
                arg3: *mut ::libc::c_int, arg4: *mut ::libc::c_int)
     -> *mut ::libc::c_char;
    pub fn erand48(arg1: *mut ::libc::c_ushort) -> ::libc::c_double;
    pub fn fcvt(arg1: ::libc::c_double, arg2: ::libc::c_int,
                arg3: *mut ::libc::c_int, arg4: *mut ::libc::c_int)
     -> *mut ::libc::c_char;
    pub fn gcvt(arg1: ::libc::c_double, arg2: ::libc::c_int,
                arg3: *mut ::libc::c_char) -> *mut ::libc::c_char;
    pub fn getsubopt(arg1: *mut *mut ::libc::c_char,
                     arg2: *const *mut ::libc::c_char,
                     arg3: *mut *mut ::libc::c_char) -> ::libc::c_int;
    pub fn grantpt(arg1: ::libc::c_int) -> ::libc::c_int;
    pub fn initstate(arg1: ::libc::c_uint, arg2: *mut ::libc::c_char,
                     arg3: size_t) -> *mut ::libc::c_char;
    pub fn jrand48(arg1: *mut ::libc::c_ushort) -> ::libc::c_long;
    pub fn l64a(arg1: ::libc::c_long) -> *mut ::libc::c_char;
    pub fn lcong48(arg1: *mut ::libc::c_ushort) -> ();
    pub fn lrand48() -> ::libc::c_long;
    pub fn mktemp(arg1: *mut ::libc::c_char) -> *mut ::libc::c_char;
    pub fn mkstemp(arg1: *mut ::libc::c_char) -> ::libc::c_int;
    pub fn mrand48() -> ::libc::c_long;
    pub fn nrand48(arg1: *mut ::libc::c_ushort) -> ::libc::c_long;
    pub fn posix_openpt(arg1: ::libc::c_int) -> ::libc::c_int;
    pub fn ptsname(arg1: ::libc::c_int) -> *mut ::libc::c_char;
    pub fn putenv(arg1: *mut ::libc::c_char) -> ::libc::c_int;
    pub fn random() -> ::libc::c_long;
    pub fn rand_r(arg1: *mut ::libc::c_uint) -> ::libc::c_int;
    pub fn realpath(arg1: *const ::libc::c_char, arg2: *mut ::libc::c_char)
     -> *mut ::libc::c_char;
    pub fn seed48(arg1: *mut ::libc::c_ushort) -> *mut ::libc::c_ushort;
    pub fn setenv(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char,
                  arg3: ::libc::c_int) -> ::libc::c_int;
    pub fn setkey(arg1: *const ::libc::c_char) -> ();
    pub fn setstate(arg1: *const ::libc::c_char) -> *mut ::libc::c_char;
    pub fn srand48(arg1: ::libc::c_long) -> ();
    pub fn srandom(arg1: ::libc::c_uint) -> ();
    pub fn unlockpt(arg1: ::libc::c_int) -> ::libc::c_int;
    pub fn unsetenv(arg1: *const ::libc::c_char) -> ::libc::c_int;
    pub fn arc4random() -> u_int32_t;
    pub fn arc4random_addrandom(arg1: *mut ::libc::c_uchar,
                                arg2: ::libc::c_int) -> ();
    pub fn arc4random_buf(arg1: *mut ::libc::c_void, arg2: size_t) -> ();
    pub fn arc4random_stir() -> ();
    pub fn arc4random_uniform(arg1: u_int32_t) -> u_int32_t;
    pub fn atexit_b(arg1: ::libc::c_void) -> ::libc::c_int;
    pub fn bsearch_b(arg1: *const ::libc::c_void, arg2: *const ::libc::c_void,
                     arg3: size_t, arg4: size_t, arg5: ::libc::c_void)
     -> *mut ::libc::c_void;
    pub fn cgetcap(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char,
                   arg3: ::libc::c_int) -> *mut ::libc::c_char;
    pub fn cgetclose() -> ::libc::c_int;
    pub fn cgetent(arg1: *mut *mut ::libc::c_char,
                   arg2: *mut *mut ::libc::c_char,
                   arg3: *const ::libc::c_char) -> ::libc::c_int;
    pub fn cgetfirst(arg1: *mut *mut ::libc::c_char,
                     arg2: *mut *mut ::libc::c_char) -> ::libc::c_int;
    pub fn cgetmatch(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char)
     -> ::libc::c_int;
    pub fn cgetnext(arg1: *mut *mut ::libc::c_char,
                    arg2: *mut *mut ::libc::c_char) -> ::libc::c_int;
    pub fn cgetnum(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char,
                   arg3: *mut ::libc::c_long) -> ::libc::c_int;
    pub fn cgetset(arg1: *const ::libc::c_char) -> ::libc::c_int;
    pub fn cgetstr(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char,
                   arg3: *mut *mut ::libc::c_char) -> ::libc::c_int;
    pub fn cgetustr(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char,
                    arg3: *mut *mut ::libc::c_char) -> ::libc::c_int;
    pub fn daemon(arg1: ::libc::c_int, arg2: ::libc::c_int) -> ::libc::c_int;
    pub fn devname(arg1: dev_t, arg2: mode_t) -> *mut ::libc::c_char;
    pub fn devname_r(arg1: dev_t, arg2: mode_t, buf: *mut ::libc::c_char,
                     len: ::libc::c_int) -> *mut ::libc::c_char;
    pub fn getbsize(arg1: *mut ::libc::c_int, arg2: *mut ::libc::c_long)
     -> *mut ::libc::c_char;
    pub fn getloadavg(arg1: *mut ::libc::c_double, arg2: ::libc::c_int)
     -> ::libc::c_int;
    pub fn getprogname() -> *const ::libc::c_char;
    pub fn heapsort(arg1: *mut ::libc::c_void, arg2: size_t, arg3: size_t,
                    arg4:
                        ::std::option::Option<extern "C" fn(arg1:
                                                                *const ::libc::c_void,
                                                            arg2:
                                                                *const ::libc::c_void)
                                                  -> ::libc::c_int>)
     -> ::libc::c_int;
    pub fn heapsort_b(arg1: *mut ::libc::c_void, arg2: size_t, arg3: size_t,
                      arg4: ::libc::c_void) -> ::libc::c_int;
    pub fn mergesort(arg1: *mut ::libc::c_void, arg2: size_t, arg3: size_t,
                     arg4:
                         ::std::option::Option<extern "C" fn(arg1:
                                                                 *const ::libc::c_void,
                                                             arg2:
                                                                 *const ::libc::c_void)
                                                   -> ::libc::c_int>)
     -> ::libc::c_int;
    pub fn mergesort_b(arg1: *mut ::libc::c_void, arg2: size_t, arg3: size_t,
                       arg4: ::libc::c_void) -> ::libc::c_int;
    pub fn psort(arg1: *mut ::libc::c_void, arg2: size_t, arg3: size_t,
                 arg4:
                     ::std::option::Option<extern "C" fn(arg1:
                                                             *const ::libc::c_void,
                                                         arg2:
                                                             *const ::libc::c_void)
                                               -> ::libc::c_int>) -> ();
    pub fn psort_b(arg1: *mut ::libc::c_void, arg2: size_t, arg3: size_t,
                   arg4: ::libc::c_void) -> ();
    pub fn psort_r(arg1: *mut ::libc::c_void, arg2: size_t, arg3: size_t,
                   arg4: *mut ::libc::c_void,
                   arg5:
                       ::std::option::Option<extern "C" fn(arg1:
                                                               *mut ::libc::c_void,
                                                           arg2:
                                                               *const ::libc::c_void,
                                                           arg3:
                                                               *const ::libc::c_void)
                                                 -> ::libc::c_int>) -> ();
    pub fn qsort_b(arg1: *mut ::libc::c_void, arg2: size_t, arg3: size_t,
                   arg4: ::libc::c_void) -> ();
    pub fn qsort_r(arg1: *mut ::libc::c_void, arg2: size_t, arg3: size_t,
                   arg4: *mut ::libc::c_void,
                   arg5:
                       ::std::option::Option<extern "C" fn(arg1:
                                                               *mut ::libc::c_void,
                                                           arg2:
                                                               *const ::libc::c_void,
                                                           arg3:
                                                               *const ::libc::c_void)
                                                 -> ::libc::c_int>) -> ();
    pub fn radixsort(arg1: *mut *const ::libc::c_uchar, arg2: ::libc::c_int,
                     arg3: *const ::libc::c_uchar, arg4: ::libc::c_uint)
     -> ::libc::c_int;
    pub fn setprogname(arg1: *const ::libc::c_char) -> ();
    pub fn sradixsort(arg1: *mut *const ::libc::c_uchar, arg2: ::libc::c_int,
                      arg3: *const ::libc::c_uchar, arg4: ::libc::c_uint)
     -> ::libc::c_int;
    pub fn sranddev() -> ();
    pub fn srandomdev() -> ();
    pub fn reallocf(arg1: *mut ::libc::c_void, arg2: size_t)
     -> *mut ::libc::c_void;
    pub fn strtoq(arg1: *const ::libc::c_char, arg2: *mut *mut ::libc::c_char,
                  arg3: ::libc::c_int) -> ::libc::c_longlong;
    pub fn strtouq(arg1: *const ::libc::c_char,
                   arg2: *mut *mut ::libc::c_char, arg3: ::libc::c_int)
     -> ::libc::c_ulonglong;
    pub fn valloc(arg1: size_t) -> *mut ::libc::c_void;
    pub fn memchr(arg1: *const ::libc::c_void, arg2: ::libc::c_int,
                  arg3: size_t) -> *mut ::libc::c_void;
    pub fn memcmp(arg1: *const ::libc::c_void, arg2: *const ::libc::c_void,
                  arg3: size_t) -> ::libc::c_int;
    pub fn memcpy(arg1: *mut ::libc::c_void, arg2: *const ::libc::c_void,
                  arg3: size_t) -> *mut ::libc::c_void;
    pub fn memmove(arg1: *mut ::libc::c_void, arg2: *const ::libc::c_void,
                   arg3: size_t) -> *mut ::libc::c_void;
    pub fn memset(arg1: *mut ::libc::c_void, arg2: ::libc::c_int,
                  arg3: size_t) -> *mut ::libc::c_void;
    pub fn strcat(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char)
     -> *mut ::libc::c_char;
    pub fn strchr(arg1: *const ::libc::c_char, arg2: ::libc::c_int)
     -> *mut ::libc::c_char;
    pub fn strcmp(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char)
     -> ::libc::c_int;
    pub fn strcoll(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char)
     -> ::libc::c_int;
    pub fn strcpy(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char)
     -> *mut ::libc::c_char;
    pub fn strcspn(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char)
     -> size_t;
    pub fn strerror(arg1: ::libc::c_int) -> *mut ::libc::c_char;
    pub fn strlen(arg1: *const ::libc::c_char) -> size_t;
    pub fn strncat(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char,
                   arg3: size_t) -> *mut ::libc::c_char;
    pub fn strncmp(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char,
                   arg3: size_t) -> ::libc::c_int;
    pub fn strncpy(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char,
                   arg3: size_t) -> *mut ::libc::c_char;
    pub fn strpbrk(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char)
     -> *mut ::libc::c_char;
    pub fn strrchr(arg1: *const ::libc::c_char, arg2: ::libc::c_int)
     -> *mut ::libc::c_char;
    pub fn strspn(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char)
     -> size_t;
    pub fn strstr(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char)
     -> *mut ::libc::c_char;
    pub fn strtok(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char)
     -> *mut ::libc::c_char;
    pub fn strxfrm(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char,
                   arg3: size_t) -> size_t;
    pub fn strtok_r(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char,
                    arg3: *mut *mut ::libc::c_char) -> *mut ::libc::c_char;
    pub fn strerror_r(arg1: ::libc::c_int, arg2: *mut ::libc::c_char,
                      arg3: size_t) -> ::libc::c_int;
    pub fn strdup(arg1: *const ::libc::c_char) -> *mut ::libc::c_char;
    pub fn memccpy(arg1: *mut ::libc::c_void, arg2: *const ::libc::c_void,
                   arg3: ::libc::c_int, arg4: size_t) -> *mut ::libc::c_void;
    pub fn stpcpy(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char)
     -> *mut ::libc::c_char;
    pub fn stpncpy(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char,
                   arg3: size_t) -> *mut ::libc::c_char;
    pub fn strndup(arg1: *const ::libc::c_char, arg2: size_t)
     -> *mut ::libc::c_char;
    pub fn strnlen(arg1: *const ::libc::c_char, arg2: size_t) -> size_t;
    pub fn strsignal(sig: ::libc::c_int) -> *mut ::libc::c_char;
    pub fn memset_s(arg1: *mut ::libc::c_void, arg2: rsize_t,
                    arg3: ::libc::c_int, arg4: rsize_t) -> errno_t;
    pub fn memmem(arg1: *const ::libc::c_void, arg2: size_t,
                  arg3: *const ::libc::c_void, arg4: size_t)
     -> *mut ::libc::c_void;
    pub fn memset_pattern4(arg1: *mut ::libc::c_void,
                           arg2: *const ::libc::c_void, arg3: size_t) -> ();
    pub fn memset_pattern8(arg1: *mut ::libc::c_void,
                           arg2: *const ::libc::c_void, arg3: size_t) -> ();
    pub fn memset_pattern16(arg1: *mut ::libc::c_void,
                            arg2: *const ::libc::c_void, arg3: size_t) -> ();
    pub fn strcasestr(arg1: *const ::libc::c_char,
                      arg2: *const ::libc::c_char) -> *mut ::libc::c_char;
    pub fn strnstr(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char,
                   arg3: size_t) -> *mut ::libc::c_char;
    pub fn strlcat(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char,
                   arg3: size_t) -> size_t;
    pub fn strlcpy(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char,
                   arg3: size_t) -> size_t;
    pub fn strmode(arg1: ::libc::c_int, arg2: *mut ::libc::c_char) -> ();
    pub fn strsep(arg1: *mut *mut ::libc::c_char, arg2: *const ::libc::c_char)
     -> *mut ::libc::c_char;
    pub fn swab(arg1: *const ::libc::c_void, arg2: *mut ::libc::c_void,
                arg3: ssize_t) -> ();
    pub fn bcmp(arg1: *const ::libc::c_void, arg2: *const ::libc::c_void,
                arg3: size_t) -> ::libc::c_int;
    pub fn bcopy(arg1: *const ::libc::c_void, arg2: *mut ::libc::c_void,
                 arg3: size_t) -> ();
    pub fn bzero(arg1: *mut ::libc::c_void, arg2: size_t) -> ();
    pub fn index(arg1: *const ::libc::c_char, arg2: ::libc::c_int)
     -> *mut ::libc::c_char;
    pub fn rindex(arg1: *const ::libc::c_char, arg2: ::libc::c_int)
     -> *mut ::libc::c_char;
    pub fn ffs(arg1: ::libc::c_int) -> ::libc::c_int;
    pub fn strcasecmp(arg1: *const ::libc::c_char,
                      arg2: *const ::libc::c_char) -> ::libc::c_int;
    pub fn strncasecmp(arg1: *const ::libc::c_char,
                       arg2: *const ::libc::c_char, arg3: size_t)
     -> ::libc::c_int;
    pub fn ffsl(arg1: ::libc::c_long) -> ::libc::c_int;
    pub fn ffsll(arg1: ::libc::c_longlong) -> ::libc::c_int;
    pub fn fls(arg1: ::libc::c_int) -> ::libc::c_int;
    pub fn flsl(arg1: ::libc::c_long) -> ::libc::c_int;
    pub fn flsll(arg1: ::libc::c_longlong) -> ::libc::c_int;
    pub fn __error() -> *mut ::libc::c_int;
    pub fn localeconv() -> *mut Struct_lconv;
    pub fn setlocale(arg1: ::libc::c_int, arg2: *const ::libc::c_char)
     -> *mut ::libc::c_char;
    pub fn fdatasync(fildes: ::libc::c_int) -> ::libc::c_int;
    pub fn ___runetype(arg1: __darwin_ct_rune_t) -> ::libc::c_ulong;
    pub fn ___tolower(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
    pub fn ___toupper(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
    pub fn isascii(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn __maskrune(arg1: __darwin_ct_rune_t, arg2: ::libc::c_ulong)
     -> ::libc::c_int;
    pub fn __istype(_c: __darwin_ct_rune_t, _f: ::libc::c_ulong)
     -> ::libc::c_int;
    pub fn __isctype(_c: __darwin_ct_rune_t, _f: ::libc::c_ulong)
     -> __darwin_ct_rune_t;
    pub fn __toupper(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
    pub fn __tolower(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
    pub fn __wcwidth(_c: __darwin_ct_rune_t) -> ::libc::c_int;
    pub fn isalnum(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn isalpha(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn isblank(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn iscntrl(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn isdigit(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn isgraph(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn islower(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn isprint(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn ispunct(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn isspace(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn isupper(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn isxdigit(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn toascii(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn tolower(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn toupper(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn digittoint(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn ishexnumber(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn isideogram(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn isnumber(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn isphonogram(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn isrune(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn isspecial(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn accept(arg1: ::libc::c_int, arg2: *mut Struct_sockaddr,
                  arg3: *mut socklen_t) -> ::libc::c_int;
    pub fn bind(arg1: ::libc::c_int, arg2: *const Struct_sockaddr,
                arg3: socklen_t) -> ::libc::c_int;
    pub fn connect(arg1: ::libc::c_int, arg2: *const Struct_sockaddr,
                   arg3: socklen_t) -> ::libc::c_int;
    pub fn getpeername(arg1: ::libc::c_int, arg2: *mut Struct_sockaddr,
                       arg3: *mut socklen_t) -> ::libc::c_int;
    pub fn getsockname(arg1: ::libc::c_int, arg2: *mut Struct_sockaddr,
                       arg3: *mut socklen_t) -> ::libc::c_int;
    pub fn getsockopt(arg1: ::libc::c_int, arg2: ::libc::c_int,
                      arg3: ::libc::c_int, arg4: *mut ::libc::c_void,
                      arg5: *mut socklen_t) -> ::libc::c_int;
    pub fn listen(arg1: ::libc::c_int, arg2: ::libc::c_int) -> ::libc::c_int;
    pub fn recv(arg1: ::libc::c_int, arg2: *mut ::libc::c_void, arg3: size_t,
                arg4: ::libc::c_int) -> ssize_t;
    pub fn recvfrom(arg1: ::libc::c_int, arg2: *mut ::libc::c_void,
                    arg3: size_t, arg4: ::libc::c_int,
                    arg5: *mut Struct_sockaddr, arg6: *mut socklen_t)
     -> ssize_t;
    pub fn recvmsg(arg1: ::libc::c_int, arg2: *mut Struct_msghdr,
                   arg3: ::libc::c_int) -> ssize_t;
    pub fn send(arg1: ::libc::c_int, arg2: *const ::libc::c_void,
                arg3: size_t, arg4: ::libc::c_int) -> ssize_t;
    pub fn sendmsg(arg1: ::libc::c_int, arg2: *const Struct_msghdr,
                   arg3: ::libc::c_int) -> ssize_t;
    pub fn sendto(arg1: ::libc::c_int, arg2: *const ::libc::c_void,
                  arg3: size_t, arg4: ::libc::c_int,
                  arg5: *const Struct_sockaddr, arg6: socklen_t) -> ssize_t;
    pub fn setsockopt(arg1: ::libc::c_int, arg2: ::libc::c_int,
                      arg3: ::libc::c_int, arg4: *const ::libc::c_void,
                      arg5: socklen_t) -> ::libc::c_int;
    pub fn shutdown(arg1: ::libc::c_int, arg2: ::libc::c_int)
     -> ::libc::c_int;
    pub fn sockatmark(arg1: ::libc::c_int) -> ::libc::c_int;
    pub fn socket(arg1: ::libc::c_int, arg2: ::libc::c_int,
                  arg3: ::libc::c_int) -> ::libc::c_int;
    pub fn socketpair(arg1: ::libc::c_int, arg2: ::libc::c_int,
                      arg3: ::libc::c_int, arg4: *mut ::libc::c_int)
     -> ::libc::c_int;
    pub fn sendfile(arg1: ::libc::c_int, arg2: ::libc::c_int, arg3: off_t,
                    arg4: *mut off_t, arg5: *mut Struct_sf_hdtr,
                    arg6: ::libc::c_int) -> ::libc::c_int;
    pub fn pfctlinput(arg1: ::libc::c_int, arg2: *mut Struct_sockaddr) -> ();
    pub fn setipv4sourcefilter(arg1: ::libc::c_int, arg2: Struct_in_addr,
                               arg3: Struct_in_addr, arg4: uint32_t,
                               arg5: uint32_t, arg6: *mut Struct_in_addr)
     -> ::libc::c_int;
    pub fn getipv4sourcefilter(arg1: ::libc::c_int, arg2: Struct_in_addr,
                               arg3: Struct_in_addr, arg4: *mut uint32_t,
                               arg5: *mut uint32_t, arg6: *mut Struct_in_addr)
     -> ::libc::c_int;
    pub fn setsourcefilter(arg1: ::libc::c_int, arg2: uint32_t,
                           arg3: *mut Struct_sockaddr, arg4: socklen_t,
                           arg5: uint32_t, arg6: uint32_t,
                           arg7: *mut Struct_sockaddr_storage)
     -> ::libc::c_int;
    pub fn getsourcefilter(arg1: ::libc::c_int, arg2: uint32_t,
                           arg3: *mut Struct_sockaddr, arg4: socklen_t,
                           arg5: *mut uint32_t, arg6: *mut uint32_t,
                           arg7: *mut Struct_sockaddr_storage)
     -> ::libc::c_int;
    pub fn inet6_option_space(arg1: ::libc::c_int) -> ::libc::c_int;
    pub fn inet6_option_init(arg1: *mut ::libc::c_void,
                             arg2: *mut *mut Struct_cmsghdr,
                             arg3: ::libc::c_int) -> ::libc::c_int;
    pub fn inet6_option_append(arg1: *mut Struct_cmsghdr,
                               arg2: *const __uint8_t, arg3: ::libc::c_int,
                               arg4: ::libc::c_int) -> ::libc::c_int;
    pub fn inet6_option_alloc(arg1: *mut Struct_cmsghdr, arg2: ::libc::c_int,
                              arg3: ::libc::c_int, arg4: ::libc::c_int)
     -> *mut __uint8_t;
    pub fn inet6_option_next(arg1: *const Struct_cmsghdr,
                             arg2: *mut *mut __uint8_t) -> ::libc::c_int;
    pub fn inet6_option_find(arg1: *const Struct_cmsghdr,
                             arg2: *mut *mut __uint8_t, arg3: ::libc::c_int)
     -> ::libc::c_int;
    pub fn inet6_rthdr_space(arg1: ::libc::c_int, arg2: ::libc::c_int)
     -> size_t;
    pub fn inet6_rthdr_init(arg1: *mut ::libc::c_void, arg2: ::libc::c_int)
     -> *mut Struct_cmsghdr;
    pub fn inet6_rthdr_add(arg1: *mut Struct_cmsghdr,
                           arg2: *const Struct_in6_addr, arg3: ::libc::c_uint)
     -> ::libc::c_int;
    pub fn inet6_rthdr_lasthop(arg1: *mut Struct_cmsghdr,
                               arg2: ::libc::c_uint) -> ::libc::c_int;
    pub fn inet6_rthdr_segments(arg1: *const Struct_cmsghdr) -> ::libc::c_int;
    pub fn inet6_rthdr_getaddr(arg1: *mut Struct_cmsghdr, arg2: ::libc::c_int)
     -> *mut Struct_in6_addr;
    pub fn inet6_rthdr_getflags(arg1: *const Struct_cmsghdr,
                                arg2: ::libc::c_int) -> ::libc::c_int;
    pub fn inet6_opt_init(arg1: *mut ::libc::c_void, arg2: socklen_t)
     -> ::libc::c_int;
    pub fn inet6_opt_append(arg1: *mut ::libc::c_void, arg2: socklen_t,
                            arg3: ::libc::c_int, arg4: __uint8_t,
                            arg5: socklen_t, arg6: __uint8_t,
                            arg7: *mut *mut ::libc::c_void) -> ::libc::c_int;
    pub fn inet6_opt_finish(arg1: *mut ::libc::c_void, arg2: socklen_t,
                            arg3: ::libc::c_int) -> ::libc::c_int;
    pub fn inet6_opt_set_val(arg1: *mut ::libc::c_void, arg2: ::libc::c_int,
                             arg3: *mut ::libc::c_void, arg4: socklen_t)
     -> ::libc::c_int;
    pub fn inet6_opt_next(arg1: *mut ::libc::c_void, arg2: socklen_t,
                          arg3: ::libc::c_int, arg4: *mut __uint8_t,
                          arg5: *mut socklen_t,
                          arg6: *mut *mut ::libc::c_void) -> ::libc::c_int;
    pub fn inet6_opt_find(arg1: *mut ::libc::c_void, arg2: socklen_t,
                          arg3: ::libc::c_int, arg4: __uint8_t,
                          arg5: *mut socklen_t,
                          arg6: *mut *mut ::libc::c_void) -> ::libc::c_int;
    pub fn inet6_opt_get_val(arg1: *mut ::libc::c_void, arg2: ::libc::c_int,
                             arg3: *mut ::libc::c_void, arg4: socklen_t)
     -> ::libc::c_int;
    pub fn inet6_rth_space(arg1: ::libc::c_int, arg2: ::libc::c_int)
     -> socklen_t;
    pub fn inet6_rth_init(arg1: *mut ::libc::c_void, arg2: socklen_t,
                          arg3: ::libc::c_int, arg4: ::libc::c_int)
     -> *mut ::libc::c_void;
    pub fn inet6_rth_add(arg1: *mut ::libc::c_void,
                         arg2: *const Struct_in6_addr) -> ::libc::c_int;
    pub fn inet6_rth_reverse(arg1: *const ::libc::c_void,
                             arg2: *mut ::libc::c_void) -> ::libc::c_int;
    pub fn inet6_rth_segments(arg1: *const ::libc::c_void) -> ::libc::c_int;
    pub fn inet6_rth_getaddr(arg1: *const ::libc::c_void, arg2: ::libc::c_int)
     -> *mut Struct_in6_addr;
    pub fn addrsel_policy_init() -> ();
    pub fn bindresvport(arg1: ::libc::c_int, arg2: *mut Struct_sockaddr_in)
     -> ::libc::c_int;
    pub fn bindresvport_sa(arg1: ::libc::c_int, arg2: *mut Struct_sockaddr)
     -> ::libc::c_int;
    pub fn endhostent() -> ();
    pub fn endnetent() -> ();
    pub fn endprotoent() -> ();
    pub fn endservent() -> ();
    pub fn freeaddrinfo(arg1: *mut Struct_addrinfo) -> ();
    pub fn gai_strerror(arg1: ::libc::c_int) -> *const ::libc::c_char;
    pub fn getaddrinfo(arg1: *const ::libc::c_char,
                       arg2: *const ::libc::c_char,
                       arg3: *const Struct_addrinfo,
                       arg4: *mut *mut Struct_addrinfo) -> ::libc::c_int;
    pub fn gethostbyaddr(arg1: *const ::libc::c_void, arg2: socklen_t,
                         arg3: ::libc::c_int) -> *mut Struct_hostent;
    pub fn gethostbyname(arg1: *const ::libc::c_char) -> *mut Struct_hostent;
    pub fn gethostent() -> *mut Struct_hostent;
    pub fn getnameinfo(arg1: *const Struct_sockaddr, arg2: socklen_t,
                       arg3: *mut ::libc::c_char, arg4: socklen_t,
                       arg5: *mut ::libc::c_char, arg6: socklen_t,
                       arg7: ::libc::c_int) -> ::libc::c_int;
    pub fn getnetbyaddr(arg1: uint32_t, arg2: ::libc::c_int)
     -> *mut Struct_netent;
    pub fn getnetbyname(arg1: *const ::libc::c_char) -> *mut Struct_netent;
    pub fn getnetent() -> *mut Struct_netent;
    pub fn getprotobyname(arg1: *const ::libc::c_char)
     -> *mut Struct_protoent;
    pub fn getprotobynumber(arg1: ::libc::c_int) -> *mut Struct_protoent;
    pub fn getprotoent() -> *mut Struct_protoent;
    pub fn getservbyname(arg1: *const ::libc::c_char,
                         arg2: *const ::libc::c_char) -> *mut Struct_servent;
    pub fn getservbyport(arg1: ::libc::c_int, arg2: *const ::libc::c_char)
     -> *mut Struct_servent;
    pub fn getservent() -> *mut Struct_servent;
    pub fn sethostent(arg1: ::libc::c_int) -> ();
    pub fn setnetent(arg1: ::libc::c_int) -> ();
    pub fn setprotoent(arg1: ::libc::c_int) -> ();
    pub fn setservent(arg1: ::libc::c_int) -> ();
    pub fn freehostent(arg1: *mut Struct_hostent) -> ();
    pub fn gethostbyname2(arg1: *const ::libc::c_char, arg2: ::libc::c_int)
     -> *mut Struct_hostent;
    pub fn getipnodebyaddr(arg1: *const ::libc::c_void, arg2: size_t,
                           arg3: ::libc::c_int, arg4: *mut ::libc::c_int)
     -> *mut Struct_hostent;
    pub fn getipnodebyname(arg1: *const ::libc::c_char, arg2: ::libc::c_int,
                           arg3: ::libc::c_int, arg4: *mut ::libc::c_int)
     -> *mut Struct_hostent;
    pub fn getrpcbyname(name: *const ::libc::c_char) -> *mut Struct_rpcent;
    pub fn getrpcbynumber(number: ::libc::c_int) -> *mut Struct_rpcent;
    pub fn getrpcent() -> *mut Struct_rpcent;
    pub fn setrpcent(stayopen: ::libc::c_int) -> ();
    pub fn endrpcent() -> ();
    pub fn herror(arg1: *const ::libc::c_char) -> ();
    pub fn hstrerror(arg1: ::libc::c_int) -> *const ::libc::c_char;
    pub fn innetgr(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char,
                   arg3: *const ::libc::c_char, arg4: *const ::libc::c_char)
     -> ::libc::c_int;
    pub fn getnetgrent(arg1: *mut *mut ::libc::c_char,
                       arg2: *mut *mut ::libc::c_char,
                       arg3: *mut *mut ::libc::c_char) -> ::libc::c_int;
    pub fn endnetgrent() -> ();
    pub fn setnetgrent(arg1: *const ::libc::c_char) -> ();
    pub fn getpwuid(arg1: uid_t) -> *mut Struct_passwd;
    pub fn getpwnam(arg1: *const ::libc::c_char) -> *mut Struct_passwd;
    pub fn getpwuid_r(arg1: uid_t, arg2: *mut Struct_passwd,
                      arg3: *mut ::libc::c_char, arg4: size_t,
                      arg5: *mut *mut Struct_passwd) -> ::libc::c_int;
    pub fn getpwnam_r(arg1: *const ::libc::c_char, arg2: *mut Struct_passwd,
                      arg3: *mut ::libc::c_char, arg4: size_t,
                      arg5: *mut *mut Struct_passwd) -> ::libc::c_int;
    pub fn getpwent() -> *mut Struct_passwd;
    pub fn setpwent() -> ();
    pub fn endpwent() -> ();
    pub fn uuid_clear(uu: uuid_t) -> ();
    pub fn uuid_compare(uu1: uuid_t, uu2: uuid_t) -> ::libc::c_int;
    pub fn uuid_copy(dst: uuid_t, src: uuid_t) -> ();
    pub fn uuid_generate(out: uuid_t) -> ();
    pub fn uuid_generate_random(out: uuid_t) -> ();
    pub fn uuid_generate_time(out: uuid_t) -> ();
    pub fn uuid_is_null(uu: uuid_t) -> ::libc::c_int;
    pub fn uuid_parse(_in: uuid_string_t, uu: uuid_t) -> ::libc::c_int;
    pub fn uuid_unparse(uu: uuid_t, out: uuid_string_t) -> ();
    pub fn uuid_unparse_lower(uu: uuid_t, out: uuid_string_t) -> ();
    pub fn uuid_unparse_upper(uu: uuid_t, out: uuid_string_t) -> ();
    pub fn setpassent(arg1: ::libc::c_int) -> ::libc::c_int;
    pub fn user_from_uid(arg1: uid_t, arg2: ::libc::c_int)
     -> *mut ::libc::c_char;
    pub fn getpwuuid(arg1: uuid_t) -> *mut Struct_passwd;
    pub fn getpwuuid_r(arg1: uuid_t, arg2: *mut Struct_passwd,
                       arg3: *mut ::libc::c_char, arg4: size_t,
                       arg5: *mut *mut Struct_passwd) -> ::libc::c_int;
    pub fn pg_set_noblock(sock: pgsocket) -> _bool;
    pub fn pg_set_block(sock: pgsocket) -> _bool;
    pub fn has_drive_prefix(filename: *const ::libc::c_char) -> _bool;
    pub fn first_dir_separator(filename: *const ::libc::c_char)
     -> *mut ::libc::c_char;
    pub fn last_dir_separator(filename: *const ::libc::c_char)
     -> *mut ::libc::c_char;
    pub fn first_path_var_separator(pathlist: *const ::libc::c_char)
     -> *mut ::libc::c_char;
    pub fn join_path_components(ret_path: *mut ::libc::c_char,
                                head: *const ::libc::c_char,
                                tail: *const ::libc::c_char) -> ();
    pub fn canonicalize_path(path: *mut ::libc::c_char) -> ();
    pub fn make_native_path(path: *mut ::libc::c_char) -> ();
    pub fn path_contains_parent_reference(path: *const ::libc::c_char)
     -> _bool;
    pub fn path_is_relative_and_below_cwd(path: *const ::libc::c_char)
     -> _bool;
    pub fn path_is_prefix_of_path(path1: *const ::libc::c_char,
                                  path2: *const ::libc::c_char) -> _bool;
    pub fn make_absolute_path(path: *const ::libc::c_char)
     -> *mut ::libc::c_char;
    pub fn get_progname(argv0: *const ::libc::c_char)
     -> *const ::libc::c_char;
    pub fn get_share_path(my_exec_path: *const ::libc::c_char,
                          ret_path: *mut ::libc::c_char) -> ();
    pub fn get_etc_path(my_exec_path: *const ::libc::c_char,
                        ret_path: *mut ::libc::c_char) -> ();
    pub fn get_include_path(my_exec_path: *const ::libc::c_char,
                            ret_path: *mut ::libc::c_char) -> ();
    pub fn get_pkginclude_path(my_exec_path: *const ::libc::c_char,
                               ret_path: *mut ::libc::c_char) -> ();
    pub fn get_includeserver_path(my_exec_path: *const ::libc::c_char,
                                  ret_path: *mut ::libc::c_char) -> ();
    pub fn get_lib_path(my_exec_path: *const ::libc::c_char,
                        ret_path: *mut ::libc::c_char) -> ();
    pub fn get_pkglib_path(my_exec_path: *const ::libc::c_char,
                           ret_path: *mut ::libc::c_char) -> ();
    pub fn get_locale_path(my_exec_path: *const ::libc::c_char,
                           ret_path: *mut ::libc::c_char) -> ();
    pub fn get_doc_path(my_exec_path: *const ::libc::c_char,
                        ret_path: *mut ::libc::c_char) -> ();
    pub fn get_html_path(my_exec_path: *const ::libc::c_char,
                         ret_path: *mut ::libc::c_char) -> ();
    pub fn get_man_path(my_exec_path: *const ::libc::c_char,
                        ret_path: *mut ::libc::c_char) -> ();
    pub fn get_home_path(ret_path: *mut ::libc::c_char) -> _bool;
    pub fn get_parent_directory(path: *mut ::libc::c_char) -> ();
    pub fn pgfnames(path: *const ::libc::c_char) -> *mut *mut ::libc::c_char;
    pub fn pgfnames_cleanup(filenames: *mut *mut ::libc::c_char) -> ();
    pub fn set_pglocale_pgservice(argv0: *const ::libc::c_char,
                                  app: *const ::libc::c_char) -> ();
    pub fn find_my_exec(argv0: *const ::libc::c_char,
                        retpath: *mut ::libc::c_char) -> ::libc::c_int;
    pub fn find_other_exec(argv0: *const ::libc::c_char,
                           target: *const ::libc::c_char,
                           versionstr: *const ::libc::c_char,
                           retpath: *mut ::libc::c_char) -> ::libc::c_int;
    pub fn pg_usleep(microsec: ::libc::c_long) -> ();
    pub fn pg_strcasecmp(s1: *const ::libc::c_char, s2: *const ::libc::c_char)
     -> ::libc::c_int;
    pub fn pg_strncasecmp(s1: *const ::libc::c_char,
                          s2: *const ::libc::c_char, n: size_t)
     -> ::libc::c_int;
    pub fn pg_toupper(ch: ::libc::c_uchar) -> ::libc::c_uchar;
    pub fn pg_tolower(ch: ::libc::c_uchar) -> ::libc::c_uchar;
    pub fn pg_ascii_toupper(ch: ::libc::c_uchar) -> ::libc::c_uchar;
    pub fn pg_ascii_tolower(ch: ::libc::c_uchar) -> ::libc::c_uchar;
    pub fn simple_prompt(prompt: *const ::libc::c_char, maxlen: ::libc::c_int,
                         echo: _bool) -> *mut ::libc::c_char;
    pub fn pclose_check(stream: *mut FILE) -> ::libc::c_int;
    pub fn rmtree(path: *const ::libc::c_char, rmtopdir: _bool) -> _bool;
    pub fn pg_erand48(xseed: *mut ::libc::c_ushort) -> ::libc::c_double;
    pub fn pg_lrand48() -> ::libc::c_long;
    pub fn pg_srand48(seed: ::libc::c_long) -> ();
    pub fn pqStrerror(errnum: ::libc::c_int, strerrbuf: *mut ::libc::c_char,
                      buflen: size_t) -> *mut ::libc::c_char;
    pub fn pqGetpwuid(uid: uid_t, resultbuf: *mut Struct_passwd,
                      buffer: *mut ::libc::c_char, buflen: size_t,
                      result: *mut *mut Struct_passwd) -> ::libc::c_int;
    pub fn pqGethostbyname(name: *const ::libc::c_char,
                           resultbuf: *mut Struct_hostent,
                           buffer: *mut ::libc::c_char, buflen: size_t,
                           result: *mut *mut Struct_hostent,
                           herrno: *mut ::libc::c_int) -> ::libc::c_int;
    pub fn pg_qsort(base: *mut ::libc::c_void, nel: size_t, elsize: size_t,
                    cmp:
                        ::std::option::Option<extern "C" fn(arg1:
                                                                *const ::libc::c_void,
                                                            arg2:
                                                                *const ::libc::c_void)
                                                  -> ::libc::c_int>) -> ();
    pub fn pg_qsort_strcmp(a: *const ::libc::c_void, b: *const ::libc::c_void)
     -> ::libc::c_int;
    pub fn qsort_arg(base: *mut ::libc::c_void, nel: size_t, elsize: size_t,
                     cmp: qsort_arg_comparator, arg: *mut ::libc::c_void)
     -> ();
    pub fn pg_get_encoding_from_locale(ctype: *const ::libc::c_char,
                                       write_message: _bool) -> ::libc::c_int;
    pub fn inet_net_ntop(af: ::libc::c_int, src: *const ::libc::c_void,
                         bits: ::libc::c_int, dst: *mut ::libc::c_char,
                         size: size_t) -> *mut ::libc::c_char;
    pub fn pg_check_dir(dir: *const ::libc::c_char) -> ::libc::c_int;
    pub fn pg_mkdir_p(path: *mut ::libc::c_char, omode: ::libc::c_int)
     -> ::libc::c_int;
    pub fn pqsignal(signo: ::libc::c_int, func: pqsigfunc) -> pqsigfunc;
    pub fn escape_single_quotes_ascii(src: *const ::libc::c_char)
     -> *mut ::libc::c_char;
    pub fn wait_result_to_str(exit_status: ::libc::c_int)
     -> *mut ::libc::c_char;
    pub fn setjmp(arg1: jmp_buf) -> ::libc::c_int;
    pub fn longjmp(arg1: jmp_buf, arg2: ::libc::c_int) -> ();
    pub fn _setjmp(arg1: jmp_buf) -> ::libc::c_int;
    pub fn _longjmp(arg1: jmp_buf, arg2: ::libc::c_int) -> ();
    pub fn sigsetjmp(arg1: sigjmp_buf, arg2: ::libc::c_int) -> ::libc::c_int;
    pub fn siglongjmp(arg1: sigjmp_buf, arg2: ::libc::c_int) -> ();
    pub fn longjmperror() -> ();
    pub fn errstart(elevel: ::libc::c_int, filename: *const ::libc::c_char,
                    lineno: ::libc::c_int, funcname: *const ::libc::c_char,
                    domain: *const ::libc::c_char) -> _bool;
    pub fn errfinish(dummy: ::libc::c_int, ...) -> ();
    pub fn errcode(sqlerrcode: ::libc::c_int) -> ::libc::c_int;
    pub fn errcode_for_file_access() -> ::libc::c_int;
    pub fn errcode_for_socket_access() -> ::libc::c_int;
    pub fn errmsg(fmt: *const ::libc::c_char, ...) -> ::libc::c_int;
    pub fn errmsg_internal(fmt: *const ::libc::c_char, ...) -> ::libc::c_int;
    pub fn errmsg_plural(fmt_singular: *const ::libc::c_char,
                         fmt_plural: *const ::libc::c_char,
                         n: ::libc::c_ulong, ...) -> ::libc::c_int;
    pub fn errdetail(fmt: *const ::libc::c_char, ...) -> ::libc::c_int;
    pub fn errdetail_internal(fmt: *const ::libc::c_char, ...)
     -> ::libc::c_int;
    pub fn errdetail_log(fmt: *const ::libc::c_char, ...) -> ::libc::c_int;
    pub fn errdetail_log_plural(fmt_singular: *const ::libc::c_char,
                                fmt_plural: *const ::libc::c_char,
                                n: ::libc::c_ulong, ...) -> ::libc::c_int;
    pub fn errdetail_plural(fmt_singular: *const ::libc::c_char,
                            fmt_plural: *const ::libc::c_char,
                            n: ::libc::c_ulong, ...) -> ::libc::c_int;
    pub fn errhint(fmt: *const ::libc::c_char, ...) -> ::libc::c_int;
    pub fn set_errcontext_domain(domain: *const ::libc::c_char)
     -> ::libc::c_int;
    pub fn errcontext_msg(fmt: *const ::libc::c_char, ...) -> ::libc::c_int;
    pub fn errhidestmt(hide_stmt: _bool) -> ::libc::c_int;
    pub fn errfunction(funcname: *const ::libc::c_char) -> ::libc::c_int;
    pub fn errposition(cursorpos: ::libc::c_int) -> ::libc::c_int;
    pub fn internalerrposition(cursorpos: ::libc::c_int) -> ::libc::c_int;
    pub fn internalerrquery(query: *const ::libc::c_char) -> ::libc::c_int;
    pub fn err_generic_string(field: ::libc::c_int,
                              str: *const ::libc::c_char) -> ::libc::c_int;
    pub fn geterrcode() -> ::libc::c_int;
    pub fn geterrposition() -> ::libc::c_int;
    pub fn getinternalerrposition() -> ::libc::c_int;
    pub fn elog_start(filename: *const ::libc::c_char, lineno: ::libc::c_int,
                      funcname: *const ::libc::c_char) -> ();
    pub fn elog_finish(elevel: ::libc::c_int, fmt: *const ::libc::c_char, ...)
     -> ();
    pub fn pre_format_elog_string(errnumber: ::libc::c_int,
                                  domain: *const ::libc::c_char) -> ();
    pub fn format_elog_string(fmt: *const ::libc::c_char, ...)
     -> *mut ::libc::c_char;
    pub fn EmitErrorReport() -> ();
    pub fn CopyErrorData() -> *mut ErrorData;
    pub fn FreeErrorData(edata: *mut ErrorData) -> ();
    pub fn FlushErrorState() -> ();
    pub fn ReThrowError(edata: *mut ErrorData) -> ();
    pub fn pg_re_throw() -> ();
    pub fn GetErrorContextStack() -> *mut ::libc::c_char;
    pub fn DebugFileOpen() -> ();
    pub fn unpack_sql_state(sql_state: ::libc::c_int) -> *mut ::libc::c_char;
    pub fn in_error_recursion_trouble() -> _bool;
    pub fn set_syslog_parameters(ident: *const ::libc::c_char,
                                 facility: ::libc::c_int) -> ();
    pub fn write_stderr(fmt: *const ::libc::c_char, ...) -> ();
    pub fn MemoryContextAlloc(context: MemoryContext, size: Size)
     -> *mut ::libc::c_void;
    pub fn MemoryContextAllocZero(context: MemoryContext, size: Size)
     -> *mut ::libc::c_void;
    pub fn MemoryContextAllocZeroAligned(context: MemoryContext, size: Size)
     -> *mut ::libc::c_void;
    pub fn palloc(size: Size) -> *mut ::libc::c_void;
    pub fn palloc0(size: Size) -> *mut ::libc::c_void;
    pub fn repalloc(pointer: *mut ::libc::c_void, size: Size)
     -> *mut ::libc::c_void;
    pub fn pfree(pointer: *mut ::libc::c_void) -> ();
    pub fn MemoryContextAllocHuge(context: MemoryContext, size: Size)
     -> *mut ::libc::c_void;
    pub fn repalloc_huge(pointer: *mut ::libc::c_void, size: Size)
     -> *mut ::libc::c_void;
    pub fn MemoryContextStrdup(context: MemoryContext,
                               string: *const ::libc::c_char)
     -> *mut ::libc::c_char;
    pub fn pstrdup(_in: *const ::libc::c_char) -> *mut ::libc::c_char;
    pub fn pnstrdup(_in: *const ::libc::c_char, len: Size)
     -> *mut ::libc::c_char;
    pub fn psprintf(fmt: *const ::libc::c_char, ...) -> *mut ::libc::c_char;
    pub fn pvsnprintf(buf: *mut ::libc::c_char, len: size_t,
                      fmt: *const ::libc::c_char, args: va_list) -> size_t;
    pub fn DatumGetFloat4(X: Datum) -> float4;
    pub fn Float4GetDatum(X: float4) -> Datum;
    pub fn DatumGetFloat8(X: Datum) -> float8;
    pub fn Float8GetDatum(X: float8) -> Datum;
    pub fn ExceptionalCondition(conditionName: *const ::libc::c_char,
                                errorType: *const ::libc::c_char,
                                fileName: *const ::libc::c_char,
                                lineNumber: ::libc::c_int) -> ();
    pub fn ItemPointerEquals(pointer1: ItemPointer, pointer2: ItemPointer)
     -> _bool;
    pub fn ItemPointerCompare(arg1: ItemPointer, arg2: ItemPointer) -> int32;
    pub fn HeapTupleHeaderGetCmin(tup: HeapTupleHeader) -> CommandId;
    pub fn HeapTupleHeaderGetCmax(tup: HeapTupleHeader) -> CommandId;
    pub fn HeapTupleHeaderAdjustCmax(tup: HeapTupleHeader,
                                     cmax: *mut CommandId,
                                     iscombo: *mut _bool) -> ();
    pub fn HeapTupleGetUpdateXid(tuple: HeapTupleHeader) -> TransactionId;
    pub fn nodeToString(obj: *const ::libc::c_void) -> *mut ::libc::c_char;
    pub fn stringToNode(str: *mut ::libc::c_char) -> *mut ::libc::c_void;
    pub fn copyObject(obj: *const ::libc::c_void) -> *mut ::libc::c_void;
    pub fn equal(a: *const ::libc::c_void, b: *const ::libc::c_void) -> _bool;
    pub fn lappend(list: *mut List, datum: *mut ::libc::c_void) -> *mut List;
    pub fn lappend_int(list: *mut List, datum: ::libc::c_int) -> *mut List;
    pub fn lappend_oid(list: *mut List, datum: Oid) -> *mut List;
    pub fn lappend_cell(list: *mut List, prev: *mut ListCell,
                        datum: *mut ::libc::c_void) -> *mut ListCell;
    pub fn lappend_cell_int(list: *mut List, prev: *mut ListCell,
                            datum: ::libc::c_int) -> *mut ListCell;
    pub fn lappend_cell_oid(list: *mut List, prev: *mut ListCell, datum: Oid)
     -> *mut ListCell;
    pub fn lcons(datum: *mut ::libc::c_void, list: *mut List) -> *mut List;
    pub fn lcons_int(datum: ::libc::c_int, list: *mut List) -> *mut List;
    pub fn lcons_oid(datum: Oid, list: *mut List) -> *mut List;
    pub fn list_concat(list1: *mut List, list2: *mut List) -> *mut List;
    pub fn list_truncate(list: *mut List, new_size: ::libc::c_int)
     -> *mut List;
    pub fn list_nth(list: *const List, n: ::libc::c_int)
     -> *mut ::libc::c_void;
    pub fn list_nth_int(list: *const List, n: ::libc::c_int) -> ::libc::c_int;
    pub fn list_nth_oid(list: *const List, n: ::libc::c_int) -> Oid;
    pub fn list_member(list: *const List, datum: *const ::libc::c_void)
     -> _bool;
    pub fn list_member_ptr(list: *const List, datum: *const ::libc::c_void)
     -> _bool;
    pub fn list_member_int(list: *const List, datum: ::libc::c_int) -> _bool;
    pub fn list_member_oid(list: *const List, datum: Oid) -> _bool;
    pub fn list_delete(list: *mut List, datum: *mut ::libc::c_void)
     -> *mut List;
    pub fn list_delete_ptr(list: *mut List, datum: *mut ::libc::c_void)
     -> *mut List;
    pub fn list_delete_int(list: *mut List, datum: ::libc::c_int)
     -> *mut List;
    pub fn list_delete_oid(list: *mut List, datum: Oid) -> *mut List;
    pub fn list_delete_first(list: *mut List) -> *mut List;
    pub fn list_delete_cell(list: *mut List, cell: *mut ListCell,
                            prev: *mut ListCell) -> *mut List;
    pub fn list_union(list1: *const List, list2: *const List) -> *mut List;
    pub fn list_union_ptr(list1: *const List, list2: *const List)
     -> *mut List;
    pub fn list_union_int(list1: *const List, list2: *const List)
     -> *mut List;
    pub fn list_union_oid(list1: *const List, list2: *const List)
     -> *mut List;
    pub fn list_intersection(list1: *const List, list2: *const List)
     -> *mut List;
    pub fn list_difference(list1: *const List, list2: *const List)
     -> *mut List;
    pub fn list_difference_ptr(list1: *const List, list2: *const List)
     -> *mut List;
    pub fn list_difference_int(list1: *const List, list2: *const List)
     -> *mut List;
    pub fn list_difference_oid(list1: *const List, list2: *const List)
     -> *mut List;
    pub fn list_append_unique(list: *mut List, datum: *mut ::libc::c_void)
     -> *mut List;
    pub fn list_append_unique_ptr(list: *mut List, datum: *mut ::libc::c_void)
     -> *mut List;
    pub fn list_append_unique_int(list: *mut List, datum: ::libc::c_int)
     -> *mut List;
    pub fn list_append_unique_oid(list: *mut List, datum: Oid) -> *mut List;
    pub fn list_concat_unique(list1: *mut List, list2: *mut List)
     -> *mut List;
    pub fn list_concat_unique_ptr(list1: *mut List, list2: *mut List)
     -> *mut List;
    pub fn list_concat_unique_int(list1: *mut List, list2: *mut List)
     -> *mut List;
    pub fn list_concat_unique_oid(list1: *mut List, list2: *mut List)
     -> *mut List;
    pub fn list_free(list: *mut List) -> ();
    pub fn list_free_deep(list: *mut List) -> ();
    pub fn list_copy(list: *const List) -> *mut List;
    pub fn list_copy_tail(list: *const List, nskip: ::libc::c_int)
     -> *mut List;
    pub fn CreateTemplateTupleDesc(natts: ::libc::c_int, hasoid: _bool)
     -> TupleDesc;
    pub fn CreateTupleDesc(natts: ::libc::c_int, hasoid: _bool,
                           attrs: *mut Form_pg_attribute) -> TupleDesc;
    pub fn CreateTupleDescCopy(tupdesc: TupleDesc) -> TupleDesc;
    pub fn CreateTupleDescCopyConstr(tupdesc: TupleDesc) -> TupleDesc;
    pub fn TupleDescCopyEntry(dst: TupleDesc, dstAttno: AttrNumber,
                              src: TupleDesc, srcAttno: AttrNumber) -> ();
    pub fn FreeTupleDesc(tupdesc: TupleDesc) -> ();
    pub fn IncrTupleDescRefCount(tupdesc: TupleDesc) -> ();
    pub fn DecrTupleDescRefCount(tupdesc: TupleDesc) -> ();
    pub fn equalTupleDescs(tupdesc1: TupleDesc, tupdesc2: TupleDesc) -> _bool;
    pub fn TupleDescInitEntry(desc: TupleDesc, attributeNumber: AttrNumber,
                              attributeName: *const ::libc::c_char,
                              oidtypeid: Oid, typmod: int32,
                              attdim: ::libc::c_int) -> ();
    pub fn TupleDescInitEntryCollation(desc: TupleDesc,
                                       attributeNumber: AttrNumber,
                                       collationid: Oid) -> ();
    pub fn BuildDescForRelation(schema: *mut List) -> TupleDesc;
    pub fn BuildDescFromLists(names: *mut List, types: *mut List,
                              typmods: *mut List, collations: *mut List)
     -> TupleDesc;
    pub fn open(arg1: *const ::libc::c_char, arg2: ::libc::c_int, ...)
     -> ::libc::c_int;
    pub fn creat(arg1: *const ::libc::c_char, arg2: mode_t) -> ::libc::c_int;
    pub fn fcntl(arg1: ::libc::c_int, arg2: ::libc::c_int, ...)
     -> ::libc::c_int;
    pub fn openx_np(arg1: *const ::libc::c_char, arg2: ::libc::c_int,
                    arg3: filesec_t) -> ::libc::c_int;
    pub fn open_dprotected_np(arg1: *const ::libc::c_char,
                              arg2: ::libc::c_int, arg3: ::libc::c_int,
                              arg4: ::libc::c_int, ...) -> ::libc::c_int;
    pub fn flock(arg1: ::libc::c_int, arg2: ::libc::c_int) -> ::libc::c_int;
    pub fn filesec_init() -> filesec_t;
    pub fn filesec_dup(arg1: filesec_t) -> filesec_t;
    pub fn filesec_free(arg1: filesec_t) -> ();
    pub fn filesec_get_property(arg1: filesec_t, arg2: filesec_property_t,
                                arg3: *mut ::libc::c_void) -> ::libc::c_int;
    pub fn filesec_query_property(arg1: filesec_t, arg2: filesec_property_t,
                                  arg3: *mut ::libc::c_int) -> ::libc::c_int;
    pub fn filesec_set_property(arg1: filesec_t, arg2: filesec_property_t,
                                arg3: *const ::libc::c_void) -> ::libc::c_int;
    pub fn filesec_unset_property(arg1: filesec_t, arg2: filesec_property_t)
     -> ::libc::c_int;
    pub fn TransactionStartedDuringRecovery() -> _bool;
    pub fn TransactionIdDidCommit(transactionId: TransactionId) -> _bool;
    pub fn TransactionIdDidAbort(transactionId: TransactionId) -> _bool;
    pub fn TransactionIdIsKnownCompleted(transactionId: TransactionId)
     -> _bool;
    pub fn TransactionIdAbort(transactionId: TransactionId) -> ();
    pub fn TransactionIdCommitTree(xid: TransactionId, nxids: ::libc::c_int,
                                   xids: *mut TransactionId) -> ();
    pub fn TransactionIdAsyncCommitTree(xid: TransactionId,
                                        nxids: ::libc::c_int,
                                        xids: *mut TransactionId,
                                        lsn: XLogRecPtr) -> ();
    pub fn TransactionIdAbortTree(xid: TransactionId, nxids: ::libc::c_int,
                                  xids: *mut TransactionId) -> ();
    pub fn TransactionIdPrecedes(id1: TransactionId, id2: TransactionId)
     -> _bool;
    pub fn TransactionIdPrecedesOrEquals(id1: TransactionId,
                                         id2: TransactionId) -> _bool;
    pub fn TransactionIdFollows(id1: TransactionId, id2: TransactionId)
     -> _bool;
    pub fn TransactionIdFollowsOrEquals(id1: TransactionId,
                                        id2: TransactionId) -> _bool;
    pub fn TransactionIdLatest(mainxid: TransactionId, nxids: ::libc::c_int,
                               xids: *const TransactionId) -> TransactionId;
    pub fn TransactionIdGetCommitLSN(xid: TransactionId) -> XLogRecPtr;
    pub fn GetNewTransactionId(isSubXact: _bool) -> TransactionId;
    pub fn ReadNewTransactionId() -> TransactionId;
    pub fn SetTransactionIdLimit(oldest_datfrozenxid: TransactionId,
                                 oldest_datoid: Oid) -> ();
    pub fn ForceTransactionIdLimitUpdate() -> _bool;
    pub fn GetNewObjectId() -> Oid;
    pub fn PageInit(page: Page, pageSize: Size, specialSize: Size) -> ();
    pub fn PageIsVerified(page: Page, blkno: BlockNumber) -> _bool;
    pub fn PageAddItem(page: Page, item: Item, size: Size,
                       offsetNumber: OffsetNumber, overwrite: _bool,
                       is_heap: _bool) -> OffsetNumber;
    pub fn PageGetTempPage(page: Page) -> Page;
    pub fn PageGetTempPageCopy(page: Page) -> Page;
    pub fn PageGetTempPageCopySpecial(page: Page) -> Page;
    pub fn PageRestoreTempPage(tempPage: Page, oldPage: Page) -> ();
    pub fn PageRepairFragmentation(page: Page) -> ();
    pub fn PageGetFreeSpace(page: Page) -> Size;
    pub fn PageGetExactFreeSpace(page: Page) -> Size;
    pub fn PageGetHeapFreeSpace(page: Page) -> Size;
    pub fn PageIndexTupleDelete(page: Page, offset: OffsetNumber) -> ();
    pub fn PageIndexMultiDelete(page: Page, itemnos: *mut OffsetNumber,
                                nitems: ::libc::c_int) -> ();
    pub fn PageSetChecksumCopy(page: Page, blkno: BlockNumber)
     -> *mut ::libc::c_char;
    pub fn PageSetChecksumInplace(page: Page, blkno: BlockNumber) -> ();
    pub fn heap_compute_data_size(tupleDesc: TupleDesc, values: *mut Datum,
                                  isnull: *mut _bool) -> Size;
    pub fn heap_fill_tuple(tupleDesc: TupleDesc, values: *mut Datum,
                           isnull: *mut _bool, data: *mut ::libc::c_char,
                           data_size: Size, infomask: *mut uint16,
                           bit: *mut bits8) -> ();
    pub fn heap_attisnull(tup: HeapTuple, attnum: ::libc::c_int) -> _bool;
    pub fn nocachegetattr(tup: HeapTuple, attnum: ::libc::c_int,
                          att: TupleDesc) -> Datum;
    pub fn heap_getsysattr(tup: HeapTuple, attnum: ::libc::c_int,
                           tupleDesc: TupleDesc, isnull: *mut _bool) -> Datum;
    pub fn heap_copytuple(tuple: HeapTuple) -> HeapTuple;
    pub fn heap_copytuple_with_tuple(src: HeapTuple, dest: HeapTuple) -> ();
    pub fn heap_copy_tuple_as_datum(tuple: HeapTuple, tupleDesc: TupleDesc)
     -> Datum;
    pub fn heap_form_tuple(tupleDescriptor: TupleDesc, values: *mut Datum,
                           isnull: *mut _bool) -> HeapTuple;
    pub fn heap_modify_tuple(tuple: HeapTuple, tupleDesc: TupleDesc,
                             replValues: *mut Datum, replIsnull: *mut _bool,
                             doReplace: *mut _bool) -> HeapTuple;
    pub fn heap_deform_tuple(tuple: HeapTuple, tupleDesc: TupleDesc,
                             values: *mut Datum, isnull: *mut _bool) -> ();
    pub fn heap_formtuple(tupleDescriptor: TupleDesc, values: *mut Datum,
                          nulls: *mut ::libc::c_char) -> HeapTuple;
    pub fn heap_modifytuple(tuple: HeapTuple, tupleDesc: TupleDesc,
                            replValues: *mut Datum,
                            replNulls: *mut ::libc::c_char,
                            replActions: *mut ::libc::c_char) -> HeapTuple;
    pub fn heap_deformtuple(tuple: HeapTuple, tupleDesc: TupleDesc,
                            values: *mut Datum, nulls: *mut ::libc::c_char)
     -> ();
    pub fn heap_freetuple(htup: HeapTuple) -> ();
    pub fn heap_form_minimal_tuple(tupleDescriptor: TupleDesc,
                                   values: *mut Datum, isnull: *mut _bool)
     -> MinimalTuple;
    pub fn heap_free_minimal_tuple(mtup: MinimalTuple) -> ();
    pub fn heap_copy_minimal_tuple(mtup: MinimalTuple) -> MinimalTuple;
    pub fn heap_tuple_from_minimal_tuple(mtup: MinimalTuple) -> HeapTuple;
    pub fn minimal_tuple_from_heap_tuple(htup: HeapTuple) -> MinimalTuple;
    pub fn slist_delete(head: *mut slist_head, node: *mut slist_node) -> ();
    pub fn forkname_to_number(forkName: *const ::libc::c_char) -> ForkNumber;
    pub fn forkname_chars(str: *const ::libc::c_char, fork: *mut ForkNumber)
     -> ::libc::c_int;
    pub fn GetDatabasePath(dbNode: Oid, spcNode: Oid) -> *mut ::libc::c_char;
    pub fn GetRelationPath(dbNode: Oid, spcNode: Oid, relNode: Oid,
                           backendId: ::libc::c_int, forkNumber: ForkNumber)
     -> *mut ::libc::c_char;
    pub fn SendSharedInvalidMessages(msgs: *const SharedInvalidationMessage,
                                     n: ::libc::c_int) -> ();
    pub fn ReceiveSharedInvalidMessages(invalFunction:
                                            ::std::option::Option<extern "C" fn(msg:
                                                                                    *mut SharedInvalidationMessage)
                                                                      -> ()>,
                                        resetFunction:
                                            ::std::option::Option<extern "C" fn()
                                                                      -> ()>)
     -> ();
    pub fn HandleCatchupInterrupt() -> ();
    pub fn EnableCatchupInterrupt() -> ();
    pub fn DisableCatchupInterrupt() -> _bool;
    pub fn xactGetCommittedInvalidationMessages(msgs:
                                                    *mut *mut SharedInvalidationMessage,
                                                RelcacheInitFileInval:
                                                    *mut _bool)
     -> ::libc::c_int;
    pub fn ProcessCommittedInvalidationMessages(msgs:
                                                    *mut SharedInvalidationMessage,
                                                nmsgs: ::libc::c_int,
                                                RelcacheInitFileInval: _bool,
                                                dbid: Oid, tsid: Oid) -> ();
    pub fn LocalExecuteInvalidationMessage(msg:
                                               *mut SharedInvalidationMessage)
     -> ();
    pub fn hash_create(tabname: *const ::libc::c_char, nelem: ::libc::c_long,
                       info: *mut HASHCTL, flags: ::libc::c_int) -> *mut HTAB;
    pub fn hash_destroy(hashp: *mut HTAB) -> ();
    pub fn hash_stats(_where: *const ::libc::c_char, hashp: *mut HTAB) -> ();
    pub fn hash_search(hashp: *mut HTAB, keyPtr: *const ::libc::c_void,
                       action: HASHACTION, foundPtr: *mut _bool)
     -> *mut ::libc::c_void;
    pub fn get_hash_value(hashp: *mut HTAB, keyPtr: *const ::libc::c_void)
     -> uint32;
    pub fn hash_search_with_hash_value(hashp: *mut HTAB,
                                       keyPtr: *const ::libc::c_void,
                                       hashvalue: uint32, action: HASHACTION,
                                       foundPtr: *mut _bool)
     -> *mut ::libc::c_void;
    pub fn hash_update_hash_key(hashp: *mut HTAB,
                                existingEntry: *mut ::libc::c_void,
                                newKeyPtr: *const ::libc::c_void) -> _bool;
    pub fn hash_get_num_entries(hashp: *mut HTAB) -> ::libc::c_long;
    pub fn hash_seq_init(status: *mut HASH_SEQ_STATUS, hashp: *mut HTAB)
     -> ();
    pub fn hash_seq_search(status: *mut HASH_SEQ_STATUS)
     -> *mut ::libc::c_void;
    pub fn hash_seq_term(status: *mut HASH_SEQ_STATUS) -> ();
    pub fn hash_freeze(hashp: *mut HTAB) -> ();
    pub fn hash_estimate_size(num_entries: ::libc::c_long, entrysize: Size)
     -> Size;
    pub fn hash_select_dirsize(num_entries: ::libc::c_long) -> ::libc::c_long;
    pub fn hash_get_shared_size(info: *mut HASHCTL, flags: ::libc::c_int)
     -> Size;
    pub fn AtEOXact_HashTables(isCommit: _bool) -> ();
    pub fn AtEOSubXact_HashTables(isCommit: _bool, nestDepth: ::libc::c_int)
     -> ();
    pub fn string_hash(key: *const ::libc::c_void, keysize: Size) -> uint32;
    pub fn tag_hash(key: *const ::libc::c_void, keysize: Size) -> uint32;
    pub fn oid_hash(key: *const ::libc::c_void, keysize: Size) -> uint32;
    pub fn bitmap_hash(key: *const ::libc::c_void, keysize: Size) -> uint32;
    pub fn bitmap_match(key1: *const ::libc::c_void,
                        key2: *const ::libc::c_void, keysize: Size)
     -> ::libc::c_int;
    pub fn fmgr_info(functionId: Oid, finfo: *mut FmgrInfo) -> ();
    pub fn fmgr_info_cxt(functionId: Oid, finfo: *mut FmgrInfo,
                         mcxt: MemoryContext) -> ();
    pub fn fmgr_info_copy(dstinfo: *mut FmgrInfo, srcinfo: *mut FmgrInfo,
                          destcxt: MemoryContext) -> ();
    pub fn pg_detoast_datum(datum: *mut Struct_varlena)
     -> *mut Struct_varlena;
    pub fn pg_detoast_datum_copy(datum: *mut Struct_varlena)
     -> *mut Struct_varlena;
    pub fn pg_detoast_datum_slice(datum: *mut Struct_varlena, first: int32,
                                  count: int32) -> *mut Struct_varlena;
    pub fn pg_detoast_datum_packed(datum: *mut Struct_varlena)
     -> *mut Struct_varlena;
    pub fn DirectFunctionCall1Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum) -> Datum;
    pub fn DirectFunctionCall2Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum) -> Datum;
    pub fn DirectFunctionCall3Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum)
     -> Datum;
    pub fn DirectFunctionCall4Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum) -> Datum;
    pub fn DirectFunctionCall5Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum, arg5: Datum) -> Datum;
    pub fn DirectFunctionCall6Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum, arg5: Datum, arg6: Datum)
     -> Datum;
    pub fn DirectFunctionCall7Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum, arg5: Datum, arg6: Datum,
                                   arg7: Datum) -> Datum;
    pub fn DirectFunctionCall8Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum, arg5: Datum, arg6: Datum,
                                   arg7: Datum, arg8: Datum) -> Datum;
    pub fn DirectFunctionCall9Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum, arg5: Datum, arg6: Datum,
                                   arg7: Datum, arg8: Datum, arg9: Datum)
     -> Datum;
    pub fn FunctionCall1Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum) -> Datum;
    pub fn FunctionCall2Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum) -> Datum;
    pub fn FunctionCall3Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum) -> Datum;
    pub fn FunctionCall4Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum) -> Datum;
    pub fn FunctionCall5Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum, arg5: Datum) -> Datum;
    pub fn FunctionCall6Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum, arg5: Datum, arg6: Datum) -> Datum;
    pub fn FunctionCall7Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum, arg5: Datum, arg6: Datum,
                             arg7: Datum) -> Datum;
    pub fn FunctionCall8Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum, arg5: Datum, arg6: Datum,
                             arg7: Datum, arg8: Datum) -> Datum;
    pub fn FunctionCall9Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum, arg5: Datum, arg6: Datum,
                             arg7: Datum, arg8: Datum, arg9: Datum) -> Datum;
    pub fn OidFunctionCall0Coll(functionId: Oid, collation: Oid) -> Datum;
    pub fn OidFunctionCall1Coll(functionId: Oid, collation: Oid, arg1: Datum)
     -> Datum;
    pub fn OidFunctionCall2Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum) -> Datum;
    pub fn OidFunctionCall3Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum) -> Datum;
    pub fn OidFunctionCall4Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum)
     -> Datum;
    pub fn OidFunctionCall5Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum,
                                arg5: Datum) -> Datum;
    pub fn OidFunctionCall6Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum,
                                arg5: Datum, arg6: Datum) -> Datum;
    pub fn OidFunctionCall7Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum,
                                arg5: Datum, arg6: Datum, arg7: Datum)
     -> Datum;
    pub fn OidFunctionCall8Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum,
                                arg5: Datum, arg6: Datum, arg7: Datum,
                                arg8: Datum) -> Datum;
    pub fn OidFunctionCall9Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum,
                                arg5: Datum, arg6: Datum, arg7: Datum,
                                arg8: Datum, arg9: Datum) -> Datum;
    pub fn InputFunctionCall(flinfo: *mut FmgrInfo, str: *mut ::libc::c_char,
                             typioparam: Oid, typmod: int32) -> Datum;
    pub fn OidInputFunctionCall(functionId: Oid, str: *mut ::libc::c_char,
                                typioparam: Oid, typmod: int32) -> Datum;
    pub fn OutputFunctionCall(flinfo: *mut FmgrInfo, val: Datum)
     -> *mut ::libc::c_char;
    pub fn OidOutputFunctionCall(functionId: Oid, val: Datum)
     -> *mut ::libc::c_char;
    pub fn ReceiveFunctionCall(flinfo: *mut FmgrInfo, buf: fmStringInfo,
                               typioparam: Oid, typmod: int32) -> Datum;
    pub fn OidReceiveFunctionCall(functionId: Oid, buf: fmStringInfo,
                                  typioparam: Oid, typmod: int32) -> Datum;
    pub fn SendFunctionCall(flinfo: *mut FmgrInfo, val: Datum) -> *mut bytea;
    pub fn OidSendFunctionCall(functionId: Oid, val: Datum) -> *mut bytea;
    pub fn fetch_finfo_record(filehandle: *mut ::libc::c_void,
                              funcname: *mut ::libc::c_char)
     -> *const Pg_finfo_record;
    pub fn clear_external_function_hash(filehandle: *mut ::libc::c_void)
     -> ();
    pub fn fmgr_internal_function(proname: *const ::libc::c_char) -> Oid;
    pub fn get_fn_expr_rettype(flinfo: *mut FmgrInfo) -> Oid;
    pub fn get_fn_expr_argtype(flinfo: *mut FmgrInfo, argnum: ::libc::c_int)
     -> Oid;
    pub fn get_call_expr_argtype(expr: fmNodePtr, argnum: ::libc::c_int)
     -> Oid;
    pub fn get_fn_expr_arg_stable(flinfo: *mut FmgrInfo,
                                  argnum: ::libc::c_int) -> _bool;
    pub fn get_call_expr_arg_stable(expr: fmNodePtr, argnum: ::libc::c_int)
     -> _bool;
    pub fn get_fn_expr_variadic(flinfo: *mut FmgrInfo) -> _bool;
    pub fn CheckFunctionValidatorAccess(validatorOid: Oid, functionOid: Oid)
     -> _bool;
    pub fn load_external_function(filename: *mut ::libc::c_char,
                                  funcname: *mut ::libc::c_char,
                                  signalNotFound: _bool,
                                  filehandle: *mut *mut ::libc::c_void)
     -> PGFunction;
    pub fn lookup_external_function(filehandle: *mut ::libc::c_void,
                                    funcname: *mut ::libc::c_char)
     -> PGFunction;
    pub fn load_file(filename: *const ::libc::c_char, restricted: _bool)
     -> ();
    pub fn find_rendezvous_variable(varName: *const ::libc::c_char)
     -> *mut *mut ::libc::c_void;
    pub fn AggCheckCallContext(fcinfo: FunctionCallInfo,
                               aggcontext: *mut MemoryContext)
     -> ::libc::c_int;
    pub fn AggGetAggref(fcinfo: FunctionCallInfo) -> fmAggrefPtr;
    pub fn AggGetTempMemoryContext(fcinfo: FunctionCallInfo) -> MemoryContext;
    pub fn AggRegisterCallback(fcinfo: FunctionCallInfo,
                               func: fmExprContextCallbackFunction,
                               arg: Datum) -> ();
    pub fn fmgr(procedureId: Oid, ...) -> *mut ::libc::c_char;
    pub fn bms_copy(a: *const Bitmapset) -> *mut Bitmapset;
    pub fn bms_equal(a: *const Bitmapset, b: *const Bitmapset) -> _bool;
    pub fn bms_make_singleton(x: ::libc::c_int) -> *mut Bitmapset;
    pub fn bms_free(a: *mut Bitmapset) -> ();
    pub fn bms_union(a: *const Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
    pub fn bms_intersect(a: *const Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
    pub fn bms_difference(a: *const Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
    pub fn bms_is_subset(a: *const Bitmapset, b: *const Bitmapset) -> _bool;
    pub fn bms_subset_compare(a: *const Bitmapset, b: *const Bitmapset)
     -> BMS_Comparison;
    pub fn bms_is_member(x: ::libc::c_int, a: *const Bitmapset) -> _bool;
    pub fn bms_overlap(a: *const Bitmapset, b: *const Bitmapset) -> _bool;
    pub fn bms_nonempty_difference(a: *const Bitmapset, b: *const Bitmapset)
     -> _bool;
    pub fn bms_singleton_member(a: *const Bitmapset) -> ::libc::c_int;
    pub fn bms_num_members(a: *const Bitmapset) -> ::libc::c_int;
    pub fn bms_membership(a: *const Bitmapset) -> BMS_Membership;
    pub fn bms_is_empty(a: *const Bitmapset) -> _bool;
    pub fn bms_add_member(a: *mut Bitmapset, x: ::libc::c_int)
     -> *mut Bitmapset;
    pub fn bms_del_member(a: *mut Bitmapset, x: ::libc::c_int)
     -> *mut Bitmapset;
    pub fn bms_add_members(a: *mut Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
    pub fn bms_int_members(a: *mut Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
    pub fn bms_del_members(a: *mut Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
    pub fn bms_join(a: *mut Bitmapset, b: *mut Bitmapset) -> *mut Bitmapset;
    pub fn bms_first_member(a: *mut Bitmapset) -> ::libc::c_int;
    pub fn bms_hash_value(a: *const Bitmapset) -> uint32;
    pub fn RelationIdGetRelation(relationId: Oid) -> Relation;
    pub fn RelationClose(relation: Relation) -> ();
    pub fn RelationGetIndexList(relation: Relation) -> *mut List;
    pub fn RelationGetOidIndex(relation: Relation) -> Oid;
    pub fn RelationGetReplicaIndex(relation: Relation) -> Oid;
    pub fn RelationGetIndexExpressions(relation: Relation) -> *mut List;
    pub fn RelationGetIndexPredicate(relation: Relation) -> *mut List;
    pub fn RelationGetIndexAttrBitmap(relation: Relation,
                                      keyAttrs: IndexAttrBitmapKind)
     -> *mut Bitmapset;
    pub fn RelationGetExclusionInfo(indexRelation: Relation,
                                    operators: *mut *mut Oid,
                                    procs: *mut *mut Oid,
                                    strategies: *mut *mut uint16) -> ();
    pub fn RelationSetIndexList(relation: Relation, indexIds: *mut List,
                                oidIndex: Oid) -> ();
    pub fn RelationInitIndexAccessInfo(relation: Relation) -> ();
    pub fn errtable(rel: Relation) -> ::libc::c_int;
    pub fn errtablecol(rel: Relation, attnum: ::libc::c_int) -> ::libc::c_int;
    pub fn errtablecolname(rel: Relation, colname: *const ::libc::c_char)
     -> ::libc::c_int;
    pub fn errtableconstraint(rel: Relation, conname: *const ::libc::c_char)
     -> ::libc::c_int;
    pub fn RelationCacheInitialize() -> ();
    pub fn RelationCacheInitializePhase2() -> ();
    pub fn RelationCacheInitializePhase3() -> ();
    pub fn RelationBuildLocalRelation(relname: *const ::libc::c_char,
                                      relnamespace: Oid, tupDesc: TupleDesc,
                                      relid: Oid, relfilenode: Oid,
                                      reltablespace: Oid,
                                      shared_relation: _bool,
                                      mapped_relation: _bool,
                                      relpersistence: ::libc::c_char,
                                      relkind: ::libc::c_char) -> Relation;
    pub fn RelationSetNewRelfilenode(relation: Relation,
                                     freezeXid: TransactionId,
                                     minmulti: MultiXactId) -> ();
    pub fn RelationForgetRelation(rid: Oid) -> ();
    pub fn RelationCacheInvalidateEntry(relationId: Oid) -> ();
    pub fn RelationCacheInvalidate() -> ();
    pub fn RelationCloseSmgrByOid(relationId: Oid) -> ();
    pub fn AtEOXact_RelationCache(isCommit: _bool) -> ();
    pub fn AtEOSubXact_RelationCache(isCommit: _bool,
                                     mySubid: SubTransactionId,
                                     parentSubid: SubTransactionId) -> ();
    pub fn RelationIdIsInInitFile(relationId: Oid) -> _bool;
    pub fn RelationCacheInitFilePreInvalidate() -> ();
    pub fn RelationCacheInitFilePostInvalidate() -> ();
    pub fn RelationCacheInitFileRemove() -> ();
    pub fn RelationIncrementReferenceCount(rel: Relation) -> ();
    pub fn RelationDecrementReferenceCount(rel: Relation) -> ();
    pub fn __math_errhandling() -> ::libc::c_int;
    pub fn __fpclassifyf(arg1: ::libc::c_float) -> ::libc::c_int;
    pub fn __fpclassifyd(arg1: ::libc::c_double) -> ::libc::c_int;
    pub fn __fpclassifyl(arg1: ::libc::c_double) -> ::libc::c_int;
    pub fn __inline_isfinitef(__x: ::libc::c_float) -> ::libc::c_int;
    pub fn __inline_isfinited(__x: ::libc::c_double) -> ::libc::c_int;
    pub fn __inline_isfinitel(__x: ::libc::c_double) -> ::libc::c_int;
    pub fn __inline_isinff(__x: ::libc::c_float) -> ::libc::c_int;
    pub fn __inline_isinfd(__x: ::libc::c_double) -> ::libc::c_int;
    pub fn __inline_isinfl(__x: ::libc::c_double) -> ::libc::c_int;
    pub fn __inline_isnanf(__x: ::libc::c_float) -> ::libc::c_int;
    pub fn __inline_isnand(__x: ::libc::c_double) -> ::libc::c_int;
    pub fn __inline_isnanl(__x: ::libc::c_double) -> ::libc::c_int;
    pub fn __inline_isnormalf(__x: ::libc::c_float) -> ::libc::c_int;
    pub fn __inline_isnormald(__x: ::libc::c_double) -> ::libc::c_int;
    pub fn __inline_isnormall(__x: ::libc::c_double) -> ::libc::c_int;
    pub fn __inline_signbitf(__x: ::libc::c_float) -> ::libc::c_int;
    pub fn __inline_signbitd(__x: ::libc::c_double) -> ::libc::c_int;
    pub fn __inline_signbitl(__x: ::libc::c_double) -> ::libc::c_int;
    pub fn acosf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn acos(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn acosl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn asinf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn asin(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn asinl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn atanf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn atan(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn atanl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn atan2f(arg1: ::libc::c_float, arg2: ::libc::c_float)
     -> ::libc::c_float;
    pub fn atan2(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn atan2l(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn cosf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn cos(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn cosl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn sinf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn sin(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn sinl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn tanf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn tan(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn tanl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn acoshf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn acosh(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn acoshl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn asinhf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn asinh(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn asinhl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn atanhf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn atanh(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn atanhl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn coshf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn cosh(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn coshl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn sinhf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn sinh(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn sinhl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn tanhf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn tanh(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn tanhl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn expf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn exp(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn expl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn exp2f(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn exp2(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn exp2l(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn expm1f(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn expm1(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn expm1l(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn logf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn log(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn logl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn log10f(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn log10(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn log10l(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn log2f(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn log2(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn log2l(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn log1pf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn log1p(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn log1pl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn logbf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn logb(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn logbl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn modff(arg1: ::libc::c_float, arg2: *mut ::libc::c_float)
     -> ::libc::c_float;
    pub fn modf(arg1: ::libc::c_double, arg2: *mut ::libc::c_double)
     -> ::libc::c_double;
    pub fn modfl(arg1: ::libc::c_double, arg2: *mut ::libc::c_double)
     -> ::libc::c_double;
    pub fn ldexpf(arg1: ::libc::c_float, arg2: ::libc::c_int)
     -> ::libc::c_float;
    pub fn ldexp(arg1: ::libc::c_double, arg2: ::libc::c_int)
     -> ::libc::c_double;
    pub fn ldexpl(arg1: ::libc::c_double, arg2: ::libc::c_int)
     -> ::libc::c_double;
    pub fn frexpf(arg1: ::libc::c_float, arg2: *mut ::libc::c_int)
     -> ::libc::c_float;
    pub fn frexp(arg1: ::libc::c_double, arg2: *mut ::libc::c_int)
     -> ::libc::c_double;
    pub fn frexpl(arg1: ::libc::c_double, arg2: *mut ::libc::c_int)
     -> ::libc::c_double;
    pub fn ilogbf(arg1: ::libc::c_float) -> ::libc::c_int;
    pub fn ilogb(arg1: ::libc::c_double) -> ::libc::c_int;
    pub fn ilogbl(arg1: ::libc::c_double) -> ::libc::c_int;
    pub fn scalbnf(arg1: ::libc::c_float, arg2: ::libc::c_int)
     -> ::libc::c_float;
    pub fn scalbn(arg1: ::libc::c_double, arg2: ::libc::c_int)
     -> ::libc::c_double;
    pub fn scalbnl(arg1: ::libc::c_double, arg2: ::libc::c_int)
     -> ::libc::c_double;
    pub fn scalblnf(arg1: ::libc::c_float, arg2: ::libc::c_long)
     -> ::libc::c_float;
    pub fn scalbln(arg1: ::libc::c_double, arg2: ::libc::c_long)
     -> ::libc::c_double;
    pub fn scalblnl(arg1: ::libc::c_double, arg2: ::libc::c_long)
     -> ::libc::c_double;
    pub fn fabsf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn fabs(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn fabsl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn cbrtf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn cbrt(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn cbrtl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn hypotf(arg1: ::libc::c_float, arg2: ::libc::c_float)
     -> ::libc::c_float;
    pub fn hypot(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn hypotl(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn powf(arg1: ::libc::c_float, arg2: ::libc::c_float)
     -> ::libc::c_float;
    pub fn pow(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn powl(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn sqrtf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn sqrt(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn sqrtl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn erff(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn erf(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn erfl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn erfcf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn erfc(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn erfcl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn lgammaf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn lgamma(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn lgammal(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn tgammaf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn tgamma(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn tgammal(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn ceilf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn ceil(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn ceill(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn floorf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn floor(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn floorl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn nearbyintf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn nearbyint(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn nearbyintl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn rintf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn rint(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn rintl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn lrintf(arg1: ::libc::c_float) -> ::libc::c_long;
    pub fn lrint(arg1: ::libc::c_double) -> ::libc::c_long;
    pub fn lrintl(arg1: ::libc::c_double) -> ::libc::c_long;
    pub fn roundf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn round(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn roundl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn lroundf(arg1: ::libc::c_float) -> ::libc::c_long;
    pub fn lround(arg1: ::libc::c_double) -> ::libc::c_long;
    pub fn lroundl(arg1: ::libc::c_double) -> ::libc::c_long;
    pub fn llrintf(arg1: ::libc::c_float) -> ::libc::c_longlong;
    pub fn llrint(arg1: ::libc::c_double) -> ::libc::c_longlong;
    pub fn llrintl(arg1: ::libc::c_double) -> ::libc::c_longlong;
    pub fn llroundf(arg1: ::libc::c_float) -> ::libc::c_longlong;
    pub fn llround(arg1: ::libc::c_double) -> ::libc::c_longlong;
    pub fn llroundl(arg1: ::libc::c_double) -> ::libc::c_longlong;
    pub fn truncf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn trunc(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn truncl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn fmodf(arg1: ::libc::c_float, arg2: ::libc::c_float)
     -> ::libc::c_float;
    pub fn fmod(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn fmodl(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn remainderf(arg1: ::libc::c_float, arg2: ::libc::c_float)
     -> ::libc::c_float;
    pub fn remainder(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn remainderl(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn remquof(arg1: ::libc::c_float, arg2: ::libc::c_float,
                   arg3: *mut ::libc::c_int) -> ::libc::c_float;
    pub fn remquo(arg1: ::libc::c_double, arg2: ::libc::c_double,
                  arg3: *mut ::libc::c_int) -> ::libc::c_double;
    pub fn remquol(arg1: ::libc::c_double, arg2: ::libc::c_double,
                   arg3: *mut ::libc::c_int) -> ::libc::c_double;
    pub fn copysignf(arg1: ::libc::c_float, arg2: ::libc::c_float)
     -> ::libc::c_float;
    pub fn copysign(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn copysignl(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn nanf(arg1: *const ::libc::c_char) -> ::libc::c_float;
    pub fn nan(arg1: *const ::libc::c_char) -> ::libc::c_double;
    pub fn nanl(arg1: *const ::libc::c_char) -> ::libc::c_double;
    pub fn nextafterf(arg1: ::libc::c_float, arg2: ::libc::c_float)
     -> ::libc::c_float;
    pub fn nextafter(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn nextafterl(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn nexttoward(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn nexttowardf(arg1: ::libc::c_float, arg2: ::libc::c_double)
     -> ::libc::c_float;
    pub fn nexttowardl(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn fdimf(arg1: ::libc::c_float, arg2: ::libc::c_float)
     -> ::libc::c_float;
    pub fn fdim(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn fdiml(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn fmaxf(arg1: ::libc::c_float, arg2: ::libc::c_float)
     -> ::libc::c_float;
    pub fn fmax(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn fmaxl(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn fminf(arg1: ::libc::c_float, arg2: ::libc::c_float)
     -> ::libc::c_float;
    pub fn fmin(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn fminl(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn fmaf(arg1: ::libc::c_float, arg2: ::libc::c_float,
                arg3: ::libc::c_float) -> ::libc::c_float;
    pub fn fma(arg1: ::libc::c_double, arg2: ::libc::c_double,
               arg3: ::libc::c_double) -> ::libc::c_double;
    pub fn fmal(arg1: ::libc::c_double, arg2: ::libc::c_double,
                arg3: ::libc::c_double) -> ::libc::c_double;
    pub fn __inff() -> ::libc::c_float;
    pub fn __inf() -> ::libc::c_double;
    pub fn __infl() -> ::libc::c_double;
    pub fn __nan() -> ::libc::c_float;
    pub fn __exp10f(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn __exp10(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn __sincosf(__x: ::libc::c_float, __sinp: *mut ::libc::c_float,
                     __cosp: *mut ::libc::c_float) -> ();
    pub fn __sincos(__x: ::libc::c_double, __sinp: *mut ::libc::c_double,
                    __cosp: *mut ::libc::c_double) -> ();
    pub fn __cospif(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn __cospi(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn __sinpif(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn __sinpi(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn __tanpif(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn __tanpi(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn __sincospif(__x: ::libc::c_float, __sinp: *mut ::libc::c_float,
                       __cosp: *mut ::libc::c_float) -> ();
    pub fn __sincospi(__x: ::libc::c_double, __sinp: *mut ::libc::c_double,
                      __cosp: *mut ::libc::c_double) -> ();
    pub fn __sincosf_stret(arg1: ::libc::c_float) -> Struct___float2;
    pub fn __sincos_stret(arg1: ::libc::c_double) -> Struct___double2;
    pub fn __sincospif_stret(arg1: ::libc::c_float) -> Struct___float2;
    pub fn __sincospi_stret(arg1: ::libc::c_double) -> Struct___double2;
    pub fn j0(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn j1(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn jn(arg1: ::libc::c_int, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn y0(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn y1(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn yn(arg1: ::libc::c_int, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn scalb(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn rinttol(arg1: ::libc::c_double) -> ::libc::c_long;
    pub fn roundtol(arg1: ::libc::c_double) -> ::libc::c_long;
    pub fn drem(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn finite(arg1: ::libc::c_double) -> ::libc::c_int;
    pub fn gamma(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn significand(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn matherr(arg1: *mut Struct_exception) -> ::libc::c_int;
    pub fn pg_localtime(timep: *const pg_time_t, tz: *const pg_tz)
     -> *mut Struct_pg_tm;
    pub fn pg_gmtime(timep: *const pg_time_t) -> *mut Struct_pg_tm;
    pub fn pg_next_dst_boundary(timep: *const pg_time_t,
                                before_gmtoff: *mut ::libc::c_long,
                                before_isdst: *mut ::libc::c_int,
                                boundary: *mut pg_time_t,
                                after_gmtoff: *mut ::libc::c_long,
                                after_isdst: *mut ::libc::c_int,
                                tz: *const pg_tz) -> ::libc::c_int;
    pub fn pg_interpret_timezone_abbrev(abbrev: *const ::libc::c_char,
                                        timep: *const pg_time_t,
                                        gmtoff: *mut ::libc::c_long,
                                        isdst: *mut ::libc::c_int,
                                        tz: *const pg_tz) -> _bool;
    pub fn pg_get_timezone_offset(tz: *const pg_tz,
                                  gmtoff: *mut ::libc::c_long) -> _bool;
    pub fn pg_get_timezone_name(tz: *mut pg_tz) -> *const ::libc::c_char;
    pub fn pg_tz_acceptable(tz: *mut pg_tz) -> _bool;
    pub fn pg_strftime(s: *mut ::libc::c_char, max: size_t,
                       format: *const ::libc::c_char, tm: *const Struct_pg_tm)
     -> size_t;
    pub fn pg_timezone_initialize() -> ();
    pub fn pg_tzset(tzname: *const ::libc::c_char) -> *mut pg_tz;
    pub fn pg_tzset_offset(gmtoffset: ::libc::c_long) -> *mut pg_tz;
    pub fn pg_tzenumerate_start() -> *mut pg_tzenum;
    pub fn pg_tzenumerate_next(dir: *mut pg_tzenum) -> *mut pg_tz;
    pub fn pg_tzenumerate_end(dir: *mut pg_tzenum) -> ();
    pub fn timestamp_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_transform(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_scale(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_finite(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_hash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_eq_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_ne_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_lt_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_le_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_gt_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_ge_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_cmp_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn make_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn make_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn make_timestamptz_at_timezone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_eq_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_ne_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_lt_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_le_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_gt_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_ge_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_cmp_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn intervaltypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn intervaltypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_transform(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_scale(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_finite(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_hash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_justify_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_justify_hours(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_justify_days(fcinfo: FunctionCallInfo) -> Datum;
    pub fn make_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_trunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_trunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_part(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_part(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_zone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_izone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptztypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptztypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_scale(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_zone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_izone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_um(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn mul_d_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_avg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_pl_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_mi_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_age(fcinfo: FunctionCallInfo) -> Datum;
    pub fn overlaps_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_pl_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_mi_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_age(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_trunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_part(fcinfo: FunctionCallInfo) -> Datum;
    pub fn now(fcinfo: FunctionCallInfo) -> Datum;
    pub fn statement_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn clock_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_postmaster_start_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_conf_load_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_series_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_series_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn GetCurrentTimestamp() -> TimestampTz;
    pub fn TimestampDifference(start_time: TimestampTz,
                               stop_time: TimestampTz,
                               secs: *mut ::libc::c_long,
                               microsecs: *mut ::libc::c_int) -> ();
    pub fn TimestampDifferenceExceeds(start_time: TimestampTz,
                                      stop_time: TimestampTz,
                                      msec: ::libc::c_int) -> _bool;
    pub fn time_t_to_timestamptz(tm: pg_time_t) -> TimestampTz;
    pub fn timestamptz_to_time_t(t: TimestampTz) -> pg_time_t;
    pub fn timestamptz_to_str(t: TimestampTz) -> *const ::libc::c_char;
    pub fn tm2timestamp(tm: *mut Struct_pg_tm, fsec: fsec_t,
                        tzp: *mut ::libc::c_int, dt: *mut Timestamp)
     -> ::libc::c_int;
    pub fn timestamp2tm(dt: Timestamp, tzp: *mut ::libc::c_int,
                        tm: *mut Struct_pg_tm, fsec: *mut fsec_t,
                        tzn: *mut *const ::libc::c_char,
                        attimezone: *mut pg_tz) -> ::libc::c_int;
    pub fn dt2time(dt: Timestamp, hour: *mut ::libc::c_int,
                   min: *mut ::libc::c_int, sec: *mut ::libc::c_int,
                   fsec: *mut fsec_t) -> ();
    pub fn interval2tm(span: Interval, tm: *mut Struct_pg_tm,
                       fsec: *mut fsec_t) -> ::libc::c_int;
    pub fn tm2interval(tm: *mut Struct_pg_tm, fsec: fsec_t,
                       span: *mut Interval) -> ::libc::c_int;
    pub fn SetEpochTimestamp() -> Timestamp;
    pub fn GetEpochTime(tm: *mut Struct_pg_tm) -> ();
    pub fn timestamp_cmp_internal(dt1: Timestamp, dt2: Timestamp)
     -> ::libc::c_int;
    pub fn isoweek2j(year: ::libc::c_int, week: ::libc::c_int)
     -> ::libc::c_int;
    pub fn isoweek2date(woy: ::libc::c_int, year: *mut ::libc::c_int,
                        mon: *mut ::libc::c_int, mday: *mut ::libc::c_int)
     -> ();
    pub fn isoweekdate2date(isoweek: ::libc::c_int, wday: ::libc::c_int,
                            year: *mut ::libc::c_int, mon: *mut ::libc::c_int,
                            mday: *mut ::libc::c_int) -> ();
    pub fn date2isoweek(year: ::libc::c_int, mon: ::libc::c_int,
                        mday: ::libc::c_int) -> ::libc::c_int;
    pub fn date2isoyear(year: ::libc::c_int, mon: ::libc::c_int,
                        mday: ::libc::c_int) -> ::libc::c_int;
    pub fn date2isoyearday(year: ::libc::c_int, mon: ::libc::c_int,
                           mday: ::libc::c_int) -> ::libc::c_int;
    pub fn ReorderBufferAllocate() -> *mut ReorderBuffer;
    pub fn ReorderBufferFree(arg1: *mut ReorderBuffer) -> ();
    pub fn ReorderBufferGetTupleBuf(arg1: *mut ReorderBuffer)
     -> *mut ReorderBufferTupleBuf;
    pub fn ReorderBufferReturnTupleBuf(arg1: *mut ReorderBuffer,
                                       tuple: *mut ReorderBufferTupleBuf)
     -> ();
    pub fn ReorderBufferGetChange(arg1: *mut ReorderBuffer)
     -> *mut ReorderBufferChange;
    pub fn ReorderBufferReturnChange(arg1: *mut ReorderBuffer,
                                     arg2: *mut ReorderBufferChange) -> ();
    pub fn ReorderBufferQueueChange(arg1: *mut ReorderBuffer,
                                    arg2: TransactionId, lsn: XLogRecPtr,
                                    arg3: *mut ReorderBufferChange) -> ();
    pub fn ReorderBufferCommit(arg1: *mut ReorderBuffer, arg2: TransactionId,
                               commit_lsn: XLogRecPtr, end_lsn: XLogRecPtr,
                               commit_time: TimestampTz) -> ();
    pub fn ReorderBufferAssignChild(arg1: *mut ReorderBuffer,
                                    arg2: TransactionId, arg3: TransactionId,
                                    commit_lsn: XLogRecPtr) -> ();
    pub fn ReorderBufferCommitChild(arg1: *mut ReorderBuffer,
                                    arg2: TransactionId, arg3: TransactionId,
                                    commit_lsn: XLogRecPtr,
                                    end_lsn: XLogRecPtr) -> ();
    pub fn ReorderBufferAbort(arg1: *mut ReorderBuffer, arg2: TransactionId,
                              lsn: XLogRecPtr) -> ();
    pub fn ReorderBufferAbortOld(arg1: *mut ReorderBuffer, xid: TransactionId)
     -> ();
    pub fn ReorderBufferForget(arg1: *mut ReorderBuffer, arg2: TransactionId,
                               lsn: XLogRecPtr) -> ();
    pub fn ReorderBufferSetBaseSnapshot(arg1: *mut ReorderBuffer,
                                        arg2: TransactionId, lsn: XLogRecPtr,
                                        snap: *mut Struct_SnapshotData) -> ();
    pub fn ReorderBufferAddSnapshot(arg1: *mut ReorderBuffer,
                                    arg2: TransactionId, lsn: XLogRecPtr,
                                    snap: *mut Struct_SnapshotData) -> ();
    pub fn ReorderBufferAddNewCommandId(arg1: *mut ReorderBuffer,
                                        arg2: TransactionId, lsn: XLogRecPtr,
                                        cid: CommandId) -> ();
    pub fn ReorderBufferAddNewTupleCids(arg1: *mut ReorderBuffer,
                                        arg2: TransactionId, lsn: XLogRecPtr,
                                        node: RelFileNode,
                                        pt: ItemPointerData, cmin: CommandId,
                                        cmax: CommandId, combocid: CommandId)
     -> ();
    pub fn ReorderBufferAddInvalidations(arg1: *mut ReorderBuffer,
                                         arg2: TransactionId, lsn: XLogRecPtr,
                                         nmsgs: Size,
                                         msgs: *mut SharedInvalidationMessage)
     -> ();
    pub fn ReorderBufferIsXidKnown(arg1: *mut ReorderBuffer,
                                   xid: TransactionId) -> _bool;
    pub fn ReorderBufferXidSetCatalogChanges(arg1: *mut ReorderBuffer,
                                             xid: TransactionId,
                                             lsn: XLogRecPtr) -> ();
    pub fn ReorderBufferXidHasCatalogChanges(arg1: *mut ReorderBuffer,
                                             xid: TransactionId) -> _bool;
    pub fn ReorderBufferXidHasBaseSnapshot(arg1: *mut ReorderBuffer,
                                           xid: TransactionId) -> _bool;
    pub fn ReorderBufferGetOldestTXN(arg1: *mut ReorderBuffer)
     -> *mut ReorderBufferTXN;
    pub fn ReorderBufferSetRestartPoint(arg1: *mut ReorderBuffer,
                                        ptr: XLogRecPtr) -> ();
    pub fn StartupReorderBuffer() -> ();
    pub fn OutputPluginPrepareWrite(ctx: *mut Struct_LogicalDecodingContext,
                                    last_write: _bool) -> ();
    pub fn OutputPluginWrite(ctx: *mut Struct_LogicalDecodingContext,
                             last_write: _bool) -> ();
    pub fn makeStringInfo() -> StringInfo;
    pub fn initStringInfo(str: StringInfo) -> ();
    pub fn resetStringInfo(str: StringInfo) -> ();
    pub fn appendStringInfo(str: StringInfo, fmt: *const ::libc::c_char, ...)
     -> ();
    pub fn appendStringInfoVA(str: StringInfo, fmt: *const ::libc::c_char,
                              args: va_list) -> ::libc::c_int;
    pub fn appendStringInfoString(str: StringInfo, s: *const ::libc::c_char)
     -> ();
    pub fn appendStringInfoChar(str: StringInfo, ch: ::libc::c_char) -> ();
    pub fn appendStringInfoSpaces(str: StringInfo, count: ::libc::c_int)
     -> ();
    pub fn appendBinaryStringInfo(str: StringInfo,
                                  data: *const ::libc::c_char,
                                  datalen: ::libc::c_int) -> ();
    pub fn enlargeStringInfo(str: StringInfo, needed: ::libc::c_int) -> ();
    pub fn XLogInsert(rmid: RmgrId, info: uint8, rdata: *mut XLogRecData)
     -> XLogRecPtr;
    pub fn XLogCheckBufferNeedsBackup(buffer: Buffer) -> _bool;
    pub fn XLogFlush(RecPtr: XLogRecPtr) -> ();
    pub fn XLogBackgroundFlush() -> _bool;
    pub fn XLogNeedsFlush(RecPtr: XLogRecPtr) -> _bool;
    pub fn XLogFileInit(segno: XLogSegNo, use_existent: *mut _bool,
                        use_lock: _bool) -> ::libc::c_int;
    pub fn XLogFileOpen(segno: XLogSegNo) -> ::libc::c_int;
    pub fn XLogSaveBufferForHint(buffer: Buffer, buffer_std: _bool)
     -> XLogRecPtr;
    pub fn CheckXLogRemoved(segno: XLogSegNo, tli: TimeLineID) -> ();
    pub fn XLogGetLastRemovedSegno() -> XLogSegNo;
    pub fn XLogSetAsyncXactLSN(record: XLogRecPtr) -> ();
    pub fn XLogSetReplicationSlotMinimumLSN(lsn: XLogRecPtr) -> ();
    pub fn RestoreBackupBlock(lsn: XLogRecPtr, record: *mut XLogRecord,
                              block_index: ::libc::c_int,
                              get_cleanup_lock: _bool, keep_buffer: _bool)
     -> Buffer;
    pub fn xlog_redo(lsn: XLogRecPtr, record: *mut XLogRecord) -> ();
    pub fn xlog_desc(buf: StringInfo, xl_info: uint8,
                     rec: *mut ::libc::c_char) -> ();
    pub fn issue_xlog_fsync(fd: ::libc::c_int, segno: XLogSegNo) -> ();
    pub fn RecoveryInProgress() -> _bool;
    pub fn HotStandbyActive() -> _bool;
    pub fn HotStandbyActiveInReplay() -> _bool;
    pub fn XLogInsertAllowed() -> _bool;
    pub fn GetXLogReceiptTime(rtime: *mut TimestampTz, fromStream: *mut _bool)
     -> ();
    pub fn GetXLogReplayRecPtr(replayTLI: *mut TimeLineID) -> XLogRecPtr;
    pub fn GetXLogInsertRecPtr() -> XLogRecPtr;
    pub fn GetXLogWriteRecPtr() -> XLogRecPtr;
    pub fn RecoveryIsPaused() -> _bool;
    pub fn SetRecoveryPause(recoveryPause: _bool) -> ();
    pub fn GetLatestXTime() -> TimestampTz;
    pub fn GetCurrentChunkReplayStartTime() -> TimestampTz;
    pub fn XLogFileNameP(tli: TimeLineID, segno: XLogSegNo)
     -> *mut ::libc::c_char;
    pub fn UpdateControlFile() -> ();
    pub fn GetSystemIdentifier() -> uint64;
    pub fn DataChecksumsEnabled() -> _bool;
    pub fn GetFakeLSNForUnloggedRel() -> XLogRecPtr;
    pub fn XLOGShmemSize() -> Size;
    pub fn XLOGShmemInit() -> ();
    pub fn BootStrapXLOG() -> ();
    pub fn StartupXLOG() -> ();
    pub fn ShutdownXLOG(code: ::libc::c_int, arg: Datum) -> ();
    pub fn InitXLOGAccess() -> ();
    pub fn CreateCheckPoint(flags: ::libc::c_int) -> ();
    pub fn CreateRestartPoint(flags: ::libc::c_int) -> _bool;
    pub fn XLogPutNextOid(nextOid: Oid) -> ();
    pub fn XLogRestorePoint(rpName: *const ::libc::c_char) -> XLogRecPtr;
    pub fn UpdateFullPageWrites() -> ();
    pub fn GetRedoRecPtr() -> XLogRecPtr;
    pub fn GetInsertRecPtr() -> XLogRecPtr;
    pub fn GetFlushRecPtr() -> XLogRecPtr;
    pub fn GetNextXidAndEpoch(xid: *mut TransactionId, epoch: *mut uint32)
     -> ();
    pub fn CheckPromoteSignal() -> _bool;
    pub fn WakeupRecovery() -> ();
    pub fn SetWalWriterSleeping(sleeping: _bool) -> ();
    pub fn do_pg_start_backup(backupidstr: *const ::libc::c_char, fast: _bool,
                              starttli_p: *mut TimeLineID,
                              labelfile: *mut *mut ::libc::c_char)
     -> XLogRecPtr;
    pub fn do_pg_stop_backup(labelfile: *mut ::libc::c_char,
                             waitforarchive: _bool,
                             stoptli_p: *mut TimeLineID) -> XLogRecPtr;
    pub fn do_pg_abort_backup() -> ();
    pub fn GetLastSegSwitchTime() -> pg_time_t;
    pub fn RequestXLogSwitch() -> XLogRecPtr;
    pub fn GetOldestRestartPoint(oldrecptr: *mut XLogRecPtr,
                                 oldtli: *mut TimeLineID) -> ();
    pub fn RestoreArchivedFile(path: *mut ::libc::c_char,
                               xlogfname: *const ::libc::c_char,
                               recovername: *const ::libc::c_char,
                               expectedSize: off_t, cleanupEnabled: _bool)
     -> _bool;
    pub fn ExecuteRecoveryCommand(command: *mut ::libc::c_char,
                                  commandName: *mut ::libc::c_char,
                                  failOnerror: _bool) -> ();
    pub fn KeepFileRestoredFromArchive(path: *mut ::libc::c_char,
                                       xlogfname: *mut ::libc::c_char) -> ();
    pub fn XLogArchiveNotify(xlog: *const ::libc::c_char) -> ();
    pub fn XLogArchiveNotifySeg(segno: XLogSegNo) -> ();
    pub fn XLogArchiveForceDone(xlog: *const ::libc::c_char) -> ();
    pub fn XLogArchiveCheckDone(xlog: *const ::libc::c_char) -> _bool;
    pub fn XLogArchiveIsBusy(xlog: *const ::libc::c_char) -> _bool;
    pub fn XLogArchiveCleanup(xlog: *const ::libc::c_char) -> ();
    pub fn XLogReaderAllocate(pagereadfunc: XLogPageReadCB,
                              private_data: *mut ::libc::c_void)
     -> *mut XLogReaderState;
    pub fn XLogReaderFree(state: *mut XLogReaderState) -> ();
    pub fn XLogReadRecord(state: *mut XLogReaderState, recptr: XLogRecPtr,
                          errormsg: *mut *mut ::libc::c_char)
     -> *mut Struct_XLogRecord;
    pub fn s_lock(lock: *mut slock_t, file: *const ::libc::c_char,
                  line: ::libc::c_int) -> ::libc::c_int;
    pub fn set_spins_per_delay(shared_spins_per_delay: ::libc::c_int) -> ();
    pub fn update_spins_per_delay(shared_spins_per_delay: ::libc::c_int)
     -> ::libc::c_int;
    pub fn LWLockAcquire(lock: *mut LWLock, mode: LWLockMode) -> _bool;
    pub fn LWLockConditionalAcquire(lock: *mut LWLock, mode: LWLockMode)
     -> _bool;
    pub fn LWLockAcquireOrWait(lock: *mut LWLock, mode: LWLockMode) -> _bool;
    pub fn LWLockRelease(lock: *mut LWLock) -> ();
    pub fn LWLockReleaseAll() -> ();
    pub fn LWLockHeldByMe(lock: *mut LWLock) -> _bool;
    pub fn LWLockAcquireWithVar(lock: *mut LWLock, valptr: *mut uint64,
                                val: uint64) -> _bool;
    pub fn LWLockWaitForVar(lock: *mut LWLock, valptr: *mut uint64,
                            oldval: uint64, newval: *mut uint64) -> _bool;
    pub fn LWLockUpdateVar(lock: *mut LWLock, valptr: *mut uint64,
                           value: uint64) -> ();
    pub fn LWLockShmemSize() -> Size;
    pub fn CreateLWLocks() -> ();
    pub fn RequestAddinLWLocks(n: ::libc::c_int) -> ();
    pub fn LWLockAssign() -> *mut LWLock;
    pub fn LWLockNewTrancheId() -> ::libc::c_int;
    pub fn LWLockRegisterTranche(arg1: ::libc::c_int,
                                 arg2: *mut LWLockTranche) -> ();
    pub fn LWLockInitialize(arg1: *mut LWLock, tranche_id: ::libc::c_int)
     -> ();
    pub fn InitShmemAccess(seghdr: *mut ::libc::c_void) -> ();
    pub fn InitShmemAllocation() -> ();
    pub fn ShmemAlloc(size: Size) -> *mut ::libc::c_void;
    pub fn ShmemAddrIsValid(addr: *const ::libc::c_void) -> _bool;
    pub fn InitShmemIndex() -> ();
    pub fn ShmemInitHash(name: *const ::libc::c_char,
                         init_size: ::libc::c_long, max_size: ::libc::c_long,
                         infoP: *mut HASHCTL, hash_flags: ::libc::c_int)
     -> *mut HTAB;
    pub fn ShmemInitStruct(name: *const ::libc::c_char, size: Size,
                           foundPtr: *mut _bool) -> *mut ::libc::c_void;
    pub fn add_size(s1: Size, s2: Size) -> Size;
    pub fn mul_size(s1: Size, s2: Size) -> Size;
    pub fn RequestAddinShmemSpace(size: Size) -> ();
    pub fn SHMQueueInit(queue: *mut SHM_QUEUE) -> ();
    pub fn SHMQueueElemInit(queue: *mut SHM_QUEUE) -> ();
    pub fn SHMQueueDelete(queue: *mut SHM_QUEUE) -> ();
    pub fn SHMQueueInsertBefore(queue: *mut SHM_QUEUE, elem: *mut SHM_QUEUE)
     -> ();
    pub fn SHMQueueInsertAfter(queue: *mut SHM_QUEUE, elem: *mut SHM_QUEUE)
     -> ();
    pub fn SHMQueueNext(queue: *const SHM_QUEUE, curElem: *const SHM_QUEUE,
                        linkOffset: Size) -> Pointer;
    pub fn SHMQueuePrev(queue: *const SHM_QUEUE, curElem: *const SHM_QUEUE,
                        linkOffset: Size) -> Pointer;
    pub fn SHMQueueEmpty(queue: *const SHM_QUEUE) -> _bool;
    pub fn SHMQueueIsDetached(queue: *const SHM_QUEUE) -> _bool;
    pub fn SpinlockSemas() -> ::libc::c_int;
    pub fn SpinlockSemaSize() -> Size;
    pub fn ReplicationSlotsShmemSize() -> Size;
    pub fn ReplicationSlotsShmemInit() -> ();
    pub fn ReplicationSlotCreate(name: *const ::libc::c_char,
                                 db_specific: _bool,
                                 p: ReplicationSlotPersistency) -> ();
    pub fn ReplicationSlotPersist() -> ();
    pub fn ReplicationSlotDrop(name: *const ::libc::c_char) -> ();
    pub fn ReplicationSlotAcquire(name: *const ::libc::c_char) -> ();
    pub fn ReplicationSlotRelease() -> ();
    pub fn ReplicationSlotSave() -> ();
    pub fn ReplicationSlotMarkDirty() -> ();
    pub fn ReplicationSlotValidateName(name: *const ::libc::c_char,
                                       elevel: ::libc::c_int) -> _bool;
    pub fn ReplicationSlotsComputeRequiredXmin(already_locked: _bool) -> ();
    pub fn ReplicationSlotsComputeRequiredLSN() -> ();
    pub fn ReplicationSlotsComputeLogicalRestartLSN() -> XLogRecPtr;
    pub fn ReplicationSlotsCountDBSlots(dboid: Oid,
                                        nslots: *mut ::libc::c_int,
                                        nactive: *mut ::libc::c_int) -> _bool;
    pub fn StartupReplicationSlots() -> ();
    pub fn CheckPointReplicationSlots() -> ();
    pub fn CheckSlotRequirements() -> ();
    pub fn pg_create_physical_replication_slot(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_create_logical_replication_slot(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_drop_replication_slot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_replication_slots(fcinfo: FunctionCallInfo) -> Datum;
    pub fn CheckLogicalDecodingRequirements() -> ();
    pub fn CreateInitDecodingContext(plugin: *mut ::libc::c_char,
                                     output_plugin_options: *mut List,
                                     read_page: XLogPageReadCB,
                                     prepare_write:
                                         LogicalOutputPluginWriterPrepareWrite,
                                     do_write: LogicalOutputPluginWriterWrite)
     -> *mut LogicalDecodingContext;
    pub fn CreateDecodingContext(start_lsn: XLogRecPtr,
                                 output_plugin_options: *mut List,
                                 read_page: XLogPageReadCB,
                                 prepare_write:
                                     LogicalOutputPluginWriterPrepareWrite,
                                 do_write: LogicalOutputPluginWriterWrite)
     -> *mut LogicalDecodingContext;
    pub fn DecodingContextFindStartpoint(ctx: *mut LogicalDecodingContext)
     -> ();
    pub fn DecodingContextReady(ctx: *mut LogicalDecodingContext) -> _bool;
    pub fn FreeDecodingContext(ctx: *mut LogicalDecodingContext) -> ();
    pub fn LogicalIncreaseXminForSlot(lsn: XLogRecPtr, xmin: TransactionId)
     -> ();
    pub fn LogicalIncreaseRestartDecodingForSlot(current_lsn: XLogRecPtr,
                                                 restart_lsn: XLogRecPtr)
     -> ();
    pub fn LogicalConfirmReceivedLocation(lsn: XLogRecPtr) -> ();
}
